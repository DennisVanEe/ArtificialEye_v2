"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//\n"
"// typical shader composition ordering (see glDrawRegistry:_CompileShader)\n"
"//\n"
"//\n"
"// - glsl version string  (#version 430)\n"
"//\n"
"// - common defines       (#define OSD_ENABLE_PATCH_CULL, ...)\n"
"// - source defines       (#define VERTEX_SHADER, ...)\n"
"//\n"
"// - osd headers          (glslPatchCommon: varying structs,\n"
"//                         glslPtexCommon: ptex functions)\n"
"// - client header        (Osd*Matrix(), displacement callback, ...)\n"
"//\n"
"// - osd shader source    (glslPatchBSpline, glslPatchGregory, ...)\n"
"//     or\n"
"//   client shader source (vertex/geometry/fragment shader)\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Common\n"
"//----------------------------------------------------------\n"
"\n"
"// XXXdyu all handling of varying data can be managed by client code\n"
"#ifndef OSD_USER_VARYING_DECLARE\n"
"#define OSD_USER_VARYING_DECLARE\n"
"// type var;\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_ATTRIBUTE_DECLARE\n"
"#define OSD_USER_VARYING_ATTRIBUTE_DECLARE\n"
"// layout(location = loc) in type var;\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_PER_VERTEX\n"
"#define OSD_USER_VARYING_PER_VERTEX()\n"
"// output.var = var;\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_PER_CONTROL_POINT\n"
"#define OSD_USER_VARYING_PER_CONTROL_POINT(ID_OUT, ID_IN)\n"
"// output[ID_OUT].var = input[ID_IN].var\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_PER_EVAL_POINT\n"
"#define OSD_USER_VARYING_PER_EVAL_POINT(UV, a, b, c, d)\n"
"// output.var =\n"
"//     mix(mix(input[a].var, input[b].var, UV.x),\n"
"//         mix(input[c].var, input[d].var, UV.x), UV.y)\n"
"#endif\n"
"\n"
"// For now, fractional spacing is supported only with screen space tessellation\n"
"#ifndef OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"#undef OSD_FRACTIONAL_EVEN_SPACING\n"
"#undef OSD_FRACTIONAL_ODD_SPACING\n"
"#endif\n"
"\n"
"#if defined OSD_FRACTIONAL_EVEN_SPACING\n"
"  #define OSD_SPACING fractional_even_spacing\n"
"#elif defined OSD_FRACTIONAL_ODD_SPACING\n"
"  #define OSD_SPACING fractional_odd_spacing\n"
"#else\n"
"  #define OSD_SPACING equal_spacing\n"
"#endif\n"
"\n"
"#define M_PI 3.14159265359f\n"
"\n"
"#if __VERSION__ < 420\n"
"    #define centroid\n"
"#endif\n"
"\n"
"struct ControlVertex {\n"
"    vec4 position;\n"
"#ifdef OSD_ENABLE_PATCH_CULL\n"
"    ivec3 clipFlag;\n"
"#endif\n"
"};\n"
"\n"
"// XXXdyu all downstream data can be handled by client code\n"
"struct OutputVertex {\n"
"    vec4 position;\n"
"    vec3 normal;\n"
"    vec3 tangent;\n"
"    vec3 bitangent;\n"
"    centroid vec4 patchCoord; // u, v, faceLevel, faceId\n"
"    centroid vec2 tessCoord; // tesscoord.st\n"
"#if defined OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    vec3 Nu;\n"
"    vec3 Nv;\n"
"#endif\n"
"};\n"
"\n"
"// osd shaders need following functions defined\n"
"mat4 OsdModelViewMatrix();\n"
"mat4 OsdProjectionMatrix();\n"
"mat4 OsdModelViewProjectionMatrix();\n"
"float OsdTessLevel();\n"
"int OsdGregoryQuadOffsetBase();\n"
"int OsdPrimitiveIdBase();\n"
"int OsdBaseVertex();\n"
"\n"
"#ifndef OSD_DISPLACEMENT_CALLBACK\n"
"#define OSD_DISPLACEMENT_CALLBACK\n"
"#endif\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Patch Parameters\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"//\n"
"// Each patch has a corresponding patchParam. This is a set of three values\n"
"// specifying additional information about the patch:\n"
"//\n"
"//    faceId    -- topological face identifier (e.g. Ptex FaceId)\n"
"//    bitfield  -- refinement-level, non-quad, boundary, transition, uv-offset\n"
"//    sharpness -- crease sharpness for single-crease patches\n"
"//\n"
"// These are stored in OsdPatchParamBuffer indexed by the value returned\n"
"// from OsdGetPatchIndex() which is a function of the current PrimitiveID\n"
"// along with an optional client provided offset.\n"
"//\n"
"\n"
"uniform isamplerBuffer OsdPatchParamBuffer;\n"
"\n"
"int OsdGetPatchIndex(int primitiveId)\n"
"{\n"
"    return (primitiveId + OsdPrimitiveIdBase());\n"
"}\n"
"\n"
"ivec3 OsdGetPatchParam(int patchIndex)\n"
"{\n"
"    return texelFetch(OsdPatchParamBuffer, patchIndex).xyz;\n"
"}\n"
"\n"
"int OsdGetPatchFaceId(ivec3 patchParam)\n"
"{\n"
"    return (patchParam.x & 0xfffffff);\n"
"}\n"
"\n"
"int OsdGetPatchFaceLevel(ivec3 patchParam)\n"
"{\n"
"    return (1 << ((patchParam.y & 0xf) - ((patchParam.y >> 4) & 1)));\n"
"}\n"
"\n"
"int OsdGetPatchRefinementLevel(ivec3 patchParam)\n"
"{\n"
"    return (patchParam.y & 0xf);\n"
"}\n"
"\n"
"int OsdGetPatchBoundaryMask(ivec3 patchParam)\n"
"{\n"
"    return ((patchParam.y >> 8) & 0xf);\n"
"}\n"
"\n"
"int OsdGetPatchTransitionMask(ivec3 patchParam)\n"
"{\n"
"    return ((patchParam.x >> 28) & 0xf);\n"
"}\n"
"\n"
"ivec2 OsdGetPatchFaceUV(ivec3 patchParam)\n"
"{\n"
"    int u = (patchParam.y >> 22) & 0x3ff;\n"
"    int v = (patchParam.y >> 12) & 0x3ff;\n"
"    return ivec2(u,v);\n"
"}\n"
"\n"
"bool OsdGetPatchIsRegular(ivec3 patchParam)\n"
"{\n"
"    return ((patchParam.y >> 5) & 0x1) != 0;\n"
"}\n"
"\n"
"float OsdGetPatchSharpness(ivec3 patchParam)\n"
"{\n"
"    return intBitsToFloat(patchParam.z);\n"
"}\n"
"\n"
"float OsdGetPatchSingleCreaseSegmentParameter(ivec3 patchParam, vec2 uv)\n"
"{\n"
"    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);\n"
"    float s = 0;\n"
"    if ((boundaryMask & 1) != 0) {\n"
"        s = 1 - uv.y;\n"
"    } else if ((boundaryMask & 2) != 0) {\n"
"        s = uv.x;\n"
"    } else if ((boundaryMask & 4) != 0) {\n"
"        s = uv.y;\n"
"    } else if ((boundaryMask & 8) != 0) {\n"
"        s = 1 - uv.x;\n"
"    }\n"
"    return s;\n"
"}\n"
"\n"
"ivec4 OsdGetPatchCoord(ivec3 patchParam)\n"
"{\n"
"    int faceId = OsdGetPatchFaceId(patchParam);\n"
"    int faceLevel = OsdGetPatchFaceLevel(patchParam);\n"
"    ivec2 faceUV = OsdGetPatchFaceUV(patchParam);\n"
"    return ivec4(faceUV.x, faceUV.y, faceLevel, faceId);\n"
"}\n"
"\n"
"vec4 OsdInterpolatePatchCoord(vec2 localUV, ivec3 patchParam)\n"
"{\n"
"    ivec4 perPrimPatchCoord = OsdGetPatchCoord(patchParam);\n"
"    int faceId = perPrimPatchCoord.w;\n"
"    int faceLevel = perPrimPatchCoord.z;\n"
"    vec2 faceUV = vec2(perPrimPatchCoord.x, perPrimPatchCoord.y);\n"
"    vec2 uv = localUV/faceLevel + faceUV/faceLevel;\n"
"    // add 0.5 to integer values for more robust interpolation\n"
"    return vec4(uv.x, uv.y, faceLevel+0.5f, faceId+0.5f);\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// face varyings\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"uniform samplerBuffer OsdFVarDataBuffer;\n"
"\n"
"#ifndef OSD_FVAR_WIDTH\n"
"#define OSD_FVAR_WIDTH 0\n"
"#endif\n"
"\n"
"// ------ extract from quads (catmark, bilinear) ---------\n"
"// XXX: only linear interpolation is supported\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_1(result, fvarOffset, tessCoord)       "
"    {                                                                   "
"        float v[4];                                                     "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 4;          "
"        for (int i = 0; i < 4; ++i) {                                   "
"            int index = (primOffset+i)*OSD_FVAR_WIDTH + fvarOffset;     "
"            v[i] = texelFetch(OsdFVarDataBuffer, index).s               "
"        }                                                               "
"        result = mix(mix(v[0], v[1], tessCoord.s),                      "
"                     mix(v[3], v[2], tessCoord.s),                      "
"                     tessCoord.t);                                      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_2(result, fvarOffset, tessCoord)       "
"    {                                                                   "
"        vec2 v[4];                                                      "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 4;          "
"        for (int i = 0; i < 4; ++i) {                                   "
"            int index = (primOffset+i)*OSD_FVAR_WIDTH + fvarOffset;     "
"            v[i] = vec2(texelFetch(OsdFVarDataBuffer, index).s,         "
"                        texelFetch(OsdFVarDataBuffer, index + 1).s);    "
"        }                                                               "
"        result = mix(mix(v[0], v[1], tessCoord.s),                      "
"                     mix(v[3], v[2], tessCoord.s),                      "
"                     tessCoord.t);                                      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_3(result, fvarOffset, tessCoord)       "
"    {                                                                   "
"        vec3 v[4];                                                      "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 4;          "
"        for (int i = 0; i < 4; ++i) {                                   "
"            int index = (primOffset+i)*OSD_FVAR_WIDTH + fvarOffset;     "
"            v[i] = vec3(texelFetch(OsdFVarDataBuffer, index).s,         "
"                        texelFetch(OsdFVarDataBuffer, index + 1).s,     "
"                        texelFetch(OsdFVarDataBuffer, index + 2).s);    "
"        }                                                               "
"        result = mix(mix(v[0], v[1], tessCoord.s),                      "
"                     mix(v[3], v[2], tessCoord.s),                      "
"                     tessCoord.t);                                      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_4(result, fvarOffset, tessCoord)       "
"    {                                                                   "
"        vec4 v[4];                                                      "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 4;          "
"        for (int i = 0; i < 4; ++i) {                                   "
"            int index = (primOffset+i)*OSD_FVAR_WIDTH + fvarOffset;     "
"            v[i] = vec4(texelFetch(OsdFVarDataBuffer, index).s,         "
"                        texelFetch(OsdFVarDataBuffer, index + 1).s,     "
"                        texelFetch(OsdFVarDataBuffer, index + 2).s,     "
"                        texelFetch(OsdFVarDataBuffer, index + 3).s);    "
"        }                                                               "
"        result = mix(mix(v[0], v[1], tessCoord.s),                      "
"                     mix(v[3], v[2], tessCoord.s),                      "
"                     tessCoord.t);                                      "
"    }\n"
"\n"
"// ------ extract from triangles (loop) ---------\n"
"// XXX: no interpolation supported\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_TRI_1(result, fvarOffset, triVert)     "
"    {                                                                   "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 3;          "
"        int index = (primOffset+triVert)*OSD_FVAR_WIDTH + fvarOffset;   "
"        result = texelFetch(OsdFVarDataBuffer, index).s;                "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_TRI_2(result, fvarOffset, triVert)     "
"    {                                                                   "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 3;          "
"        int index = (primOffset+triVert)*OSD_FVAR_WIDTH + fvarOffset;   "
"        result = vec2(texelFetch(OsdFVarDataBuffer, index).s,           "
"                      texelFetch(OsdFVarDataBuffer, index + 1).s);      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_TRI_3(result, fvarOffset, triVert)     "
"    {                                                                   "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 3;          "
"        int index = (primOffset+triVert)*OSD_FVAR_WIDTH + fvarOffset;   "
"        result = vec3(texelFetch(OsdFVarDataBuffer, index).s,           "
"                      texelFetch(OsdFVarDataBuffer, index + 1).s,       "
"                      texelFetch(OsdFVarDataBuffer, index + 2).s);      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_TRI_4(result, fvarOffset, triVert)     "
"    {                                                                   "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 3;          "
"        int index = (primOffset+triVert)*OSD_FVAR_WIDTH + fvarOffset;   "
"        result = vec4(texelFetch(OsdFVarDataBuffer, index).s,           "
"                      texelFetch(OsdFVarDataBuffer, index + 1).s,       "
"                      texelFetch(OsdFVarDataBuffer, index + 2).s,       "
"                      texelFetch(OsdFVarDataBuffer, index + 3).s);      "
"    }\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// patch culling\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"#ifdef OSD_ENABLE_PATCH_CULL\n"
"\n"
"#define OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(P)                     "
"    vec4 clipPos = OsdModelViewProjectionMatrix() * P;          "
"    bvec3 clip0 = lessThan(clipPos.xyz, vec3(clipPos.w));       "
"    bvec3 clip1 = greaterThan(clipPos.xyz, -vec3(clipPos.w));   "
"    outpt.v.clipFlag = ivec3(clip0) + 2*ivec3(clip1);           "
"\n"
"#define OSD_PATCH_CULL(N)                            "
"    ivec3 clipFlag = ivec3(0);                       "
"    for(int i = 0; i < N; ++i) {                     "
"        clipFlag |= inpt[i].v.clipFlag;              "
"    }                                                "
"    if (clipFlag != ivec3(3) ) {                     "
"        gl_TessLevelInner[0] = 0;                    "
"        gl_TessLevelInner[1] = 0;                    "
"        gl_TessLevelOuter[0] = 0;                    "
"        gl_TessLevelOuter[1] = 0;                    "
"        gl_TessLevelOuter[2] = 0;                    "
"        gl_TessLevelOuter[3] = 0;                    "
"        return;                                      "
"    }\n"
"\n"
"#else\n"
"#define OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(P)\n"
"#define OSD_PATCH_CULL(N)\n"
"#endif\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"void\n"
"OsdUnivar4x4(in float u, out float B[4], out float D[4])\n"
"{\n"
"    float t = u;\n"
"    float s = 1.0f - u;\n"
"\n"
"    float A0 = s * s;\n"
"    float A1 = 2 * s * t;\n"
"    float A2 = t * t;\n"
"\n"
"    B[0] = s * A0;\n"
"    B[1] = t * A0 + s * A1;\n"
"    B[2] = t * A1 + s * A2;\n"
"    B[3] = t * A2;\n"
"\n"
"    D[0] =    - A0;\n"
"    D[1] = A0 - A1;\n"
"    D[2] = A1 - A2;\n"
"    D[3] = A2;\n"
"}\n"
"\n"
"void\n"
"OsdUnivar4x4(in float u, out float B[4], out float D[4], out float C[4])\n"
"{\n"
"    float t = u;\n"
"    float s = 1.0f - u;\n"
"\n"
"    float A0 = s * s;\n"
"    float A1 = 2 * s * t;\n"
"    float A2 = t * t;\n"
"\n"
"    B[0] = s * A0;\n"
"    B[1] = t * A0 + s * A1;\n"
"    B[2] = t * A1 + s * A2;\n"
"    B[3] = t * A2;\n"
"\n"
"    D[0] =    - A0;\n"
"    D[1] = A0 - A1;\n"
"    D[2] = A1 - A2;\n"
"    D[3] = A2;\n"
"\n"
"    A0 =   - s;\n"
"    A1 = s - t;\n"
"    A2 = t;\n"
"\n"
"    C[0] =    - A0;\n"
"    C[1] = A0 - A1;\n"
"    C[2] = A1 - A2;\n"
"    C[3] = A2;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"struct OsdPerPatchVertexBezier {\n"
"    ivec3 patchParam;\n"
"    vec3 P;\n"
"#if defined OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    vec3 P1;\n"
"    vec3 P2;\n"
"    vec2 vSegments;\n"
"#endif\n"
"};\n"
"\n"
"vec3\n"
"OsdEvalBezier(vec3 cp[16], vec2 uv)\n"
"{\n"
"    vec3 BUCP[4] = vec3[4](vec3(0), vec3(0), vec3(0), vec3(0));\n"
"\n"
"    float B[4], D[4];\n"
"\n"
"    OsdUnivar4x4(uv.x, B, D);\n"
"    for (int i=0; i<4; ++i) {\n"
"        for (int j=0; j<4; ++j) {\n"
"            vec3 A = cp[4*i + j];\n"
"            BUCP[i] += A * B[j];\n"
"        }\n"
"    }\n"
"\n"
"    vec3 P = vec3(0);\n"
"\n"
"    OsdUnivar4x4(uv.y, B, D);\n"
"    for (int k=0; k<4; ++k) {\n"
"        P += B[k] * BUCP[k];\n"
"    }\n"
"\n"
"    return P;\n"
"}\n"
"\n"
"// When OSD_PATCH_ENABLE_SINGLE_CREASE is defined,\n"
"// this function evaluates single-crease patch, which is segmented into\n"
"// 3 parts in the v-direction.\n"
"//\n"
"//  v=0             vSegment.x        vSegment.y              v=1\n"
"//   +------------------+-------------------+------------------+\n"
"//   |       cp 0       |     cp 1          |      cp 2        |\n"
"//   | (infinite sharp) | (floor sharpness) | (ceil sharpness) |\n"
"//   +------------------+-------------------+------------------+\n"
"//\n"
"vec3\n"
"OsdEvalBezier(OsdPerPatchVertexBezier cp[16], ivec3 patchParam, vec2 uv)\n"
"{\n"
"    vec3 BUCP[4] = vec3[4](vec3(0), vec3(0), vec3(0), vec3(0));\n"
"\n"
"    float B[4], D[4];\n"
"    float s = OsdGetPatchSingleCreaseSegmentParameter(patchParam, uv);\n"
"\n"
"    OsdUnivar4x4(uv.x, B, D);\n"
"#if defined OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    vec2 vSegments = cp[0].vSegments;\n"
"    if (s <= vSegments.x) {\n"
"        for (int i=0; i<4; ++i) {\n"
"            for (int j=0; j<4; ++j) {\n"
"                vec3 A = cp[4*i + j].P;\n"
"                BUCP[i] += A * B[j];\n"
"            }\n"
"        }\n"
"    } else if (s <= vSegments.y) {\n"
"        for (int i=0; i<4; ++i) {\n"
"            for (int j=0; j<4; ++j) {\n"
"                vec3 A = cp[4*i + j].P1;\n"
"                BUCP[i] += A * B[j];\n"
"            }\n"
"        }\n"
"    } else {\n"
"        for (int i=0; i<4; ++i) {\n"
"            for (int j=0; j<4; ++j) {\n"
"                vec3 A = cp[4*i + j].P2;\n"
"                BUCP[i] += A * B[j];\n"
"            }\n"
"        }\n"
"    }\n"
"#else\n"
"    for (int i=0; i<4; ++i) {\n"
"        for (int j=0; j<4; ++j) {\n"
"            vec3 A = cp[4*i + j].P;\n"
"            BUCP[i] += A * B[j];\n"
"        }\n"
"    }\n"
"#endif\n"
"\n"
"    vec3 P = vec3(0);\n"
"\n"
"    OsdUnivar4x4(uv.y, B, D);\n"
"    for (int k=0; k<4; ++k) {\n"
"        P += B[k] * BUCP[k];\n"
"    }\n"
"\n"
"    return P;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Boundary Interpolation\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"void\n"
"OsdComputeBSplineBoundaryPoints(inout vec3 cpt[16], ivec3 patchParam)\n"
"{\n"
"    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);\n"
"\n"
"    if ((boundaryMask & 1) != 0) {\n"
"        cpt[0] = 2*cpt[4] - cpt[8];\n"
"        cpt[1] = 2*cpt[5] - cpt[9];\n"
"        cpt[2] = 2*cpt[6] - cpt[10];\n"
"        cpt[3] = 2*cpt[7] - cpt[11];\n"
"    }\n"
"    if ((boundaryMask & 2) != 0) {\n"
"        cpt[3] = 2*cpt[2] - cpt[1];\n"
"        cpt[7] = 2*cpt[6] - cpt[5];\n"
"        cpt[11] = 2*cpt[10] - cpt[9];\n"
"        cpt[15] = 2*cpt[14] - cpt[13];\n"
"    }\n"
"    if ((boundaryMask & 4) != 0) {\n"
"        cpt[12] = 2*cpt[8] - cpt[4];\n"
"        cpt[13] = 2*cpt[9] - cpt[5];\n"
"        cpt[14] = 2*cpt[10] - cpt[6];\n"
"        cpt[15] = 2*cpt[11] - cpt[7];\n"
"    }\n"
"    if ((boundaryMask & 8) != 0) {\n"
"        cpt[0] = 2*cpt[1] - cpt[2];\n"
"        cpt[4] = 2*cpt[5] - cpt[6];\n"
"        cpt[8] = 2*cpt[9] - cpt[10];\n"
"        cpt[12] = 2*cpt[13] - cpt[14];\n"
"    }\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Tessellation\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"//\n"
"// Organization of B-spline and Bezier control points.\n"
"//\n"
"// Each patch is defined by 16 control points (labeled 0-15).\n"
"//\n"
"// The patch will be evaluated across the domain from (0,0) at\n"
"// the lower-left to (1,1) at the upper-right. When computing\n"
"// adaptive tessellation metrics, we consider refined vertex-vertex\n"
"// and edge-vertex points along the transition edges of the patch\n"
"// (labeled vv* and ev* respectively).\n"
"//\n"
"// The two segments of each transition edge are labeled Lo and Hi,\n"
"// with the Lo segment occurring before the Hi segment along the\n"
"// transition edge's domain parameterization. These Lo and Hi segment\n"
"// tessellation levels determine how domain evaluation coordinates\n"
"// are remapped along transition edges. The Hi segment value will\n"
"// be zero for a non-transition edge.\n"
"//\n"
"// (0,1)                                         (1,1)\n"
"//\n"
"//   vv3                  ev23                   vv2\n"
"//        |       Lo3       |       Hi3       |\n"
"//      --O-----------O-----+-----O-----------O--\n"
"//        | 12        | 13     14 |        15 |\n"
"//        |           |           |           |\n"
"//        |           |           |           |\n"
"//    Hi0 |           |           |           | Hi2\n"
"//        |           |           |           |\n"
"//        O-----------O-----------O-----------O\n"
"//        | 8         | 9      10 |        11 |\n"
"//        |           |           |           |\n"
"// ev03 --+           |           |           +-- ev12\n"
"//        |           |           |           |\n"
"//        | 4         | 5       6 |         7 |\n"
"//        O-----------O-----------O-----------O\n"
"//        |           |           |           |\n"
"//    Lo0 |           |           |           | Lo2\n"
"//        |           |           |           |\n"
"//        |           |           |           |\n"
"//        | 0         | 1       2 |         3 |\n"
"//      --O-----------O-----+-----O-----------O--\n"
"//        |       Lo1       |       Hi1       |\n"
"//   vv0                  ev01                   vv1\n"
"//\n"
"// (0,0)                                         (1,0)\n"
"//\n"
"\n"
"#define OSD_MAX_TESS_LEVEL gl_MaxTessGenLevel\n"
"\n"
"float OsdComputePostProjectionSphereExtent(vec3 center, float diameter)\n"
"{\n"
"    vec4 p = OsdProjectionMatrix() * vec4(center, 1.0);\n"
"    return abs(diameter * OsdProjectionMatrix()[1][1] / p.w);\n"
"}\n"
"\n"
"float OsdComputeTessLevel(vec3 p0, vec3 p1)\n"
"{\n"
"    // Adaptive factor can be any computation that depends only on arg values.\n"
"    // Project the diameter of the edge's bounding sphere instead of using the\n"
"    // length of the projected edge itself to avoid problems near silhouettes.\n"
"    p0 = (OsdModelViewMatrix() * vec4(p0, 1.0)).xyz;\n"
"    p1 = (OsdModelViewMatrix() * vec4(p1, 1.0)).xyz;\n"
"    vec3 center = (p0 + p1) / 2.0;\n"
"    float diameter = distance(p0, p1);\n"
"    float projLength = OsdComputePostProjectionSphereExtent(center, diameter);\n"
"    float tessLevel = max(1.0, OsdTessLevel() * projLength);\n"
"\n"
"    // We restrict adaptive tessellation levels to half of the device\n"
"    // supported maximum because transition edges are split into two\n"
"    // halves and the sum of the two corresponding levels must not exceed\n"
"    // the device maximum. We impose this limit even for non-transition\n"
"    // edges because a non-transition edge must be able to match up with\n"
"    // one half of the transition edge of an adjacent transition patch.\n"
"    return min(tessLevel, OSD_MAX_TESS_LEVEL / 2);\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsUniform(ivec3 patchParam,\n"
"                        out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    // Uniform factors are simple powers of two for each level.\n"
"    // The maximum here can be increased if we know the maximum\n"
"    // refinement level of the mesh:\n"
"    //     min(OSD_MAX_TESS_LEVEL, pow(2, MaximumRefinementLevel-1)\n"
"    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);\n"
"    float tessLevel = min(OsdTessLevel(), OSD_MAX_TESS_LEVEL) /\n"
"                        pow(2, refinementLevel-1);\n"
"\n"
"    // tessLevels of transition edge should be clamped to 2.\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"    vec4 tessLevelMin = vec4(1) + vec4(((transitionMask & 8) >> 3),\n"
"                                       ((transitionMask & 1) >> 0),\n"
"                                       ((transitionMask & 2) >> 1),\n"
"                                       ((transitionMask & 4) >> 2));\n"
"\n"
"    tessOuterLo = max(vec4(tessLevel), tessLevelMin);\n"
"    tessOuterHi = vec4(0);\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsRefinedPoints(vec3 cp[16], ivec3 patchParam,\n"
"                              out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    // Each edge of a transition patch is adjacent to one or two patches\n"
"    // at the next refined level of subdivision. We compute the corresponding\n"
"    // vertex-vertex and edge-vertex refined points along the edges of the\n"
"    // patch using Catmull-Clark subdivision stencil weights.\n"
"    // For simplicity, we let the optimizer discard unused computation.\n"
"\n"
"    vec3 vv0 = (cp[0] + cp[2] + cp[8] + cp[10]) * 0.015625 +\n"
"               (cp[1] + cp[4] + cp[6] + cp[9]) * 0.09375 + cp[5] * 0.5625;\n"
"    vec3 ev01 = (cp[1] + cp[2] + cp[9] + cp[10]) * 0.0625 +\n"
"                (cp[5] + cp[6]) * 0.375;\n"
"\n"
"    vec3 vv1 = (cp[1] + cp[3] + cp[9] + cp[11]) * 0.015625 +\n"
"               (cp[2] + cp[5] + cp[7] + cp[10]) * 0.09375 + cp[6] * 0.5625;\n"
"    vec3 ev12 = (cp[5] + cp[7] + cp[9] + cp[11]) * 0.0625 +\n"
"                (cp[6] + cp[10]) * 0.375;\n"
"\n"
"    vec3 vv2 = (cp[5] + cp[7] + cp[13] + cp[15]) * 0.015625 +\n"
"               (cp[6] + cp[9] + cp[11] + cp[14]) * 0.09375 + cp[10] * 0.5625;\n"
"    vec3 ev23 = (cp[5] + cp[6] + cp[13] + cp[14]) * 0.0625 +\n"
"                (cp[9] + cp[10]) * 0.375;\n"
"\n"
"    vec3 vv3 = (cp[4] + cp[6] + cp[12] + cp[14]) * 0.015625 +\n"
"               (cp[5] + cp[8] + cp[10] + cp[13]) * 0.09375 + cp[9] * 0.5625;\n"
"    vec3 ev03 = (cp[4] + cp[6] + cp[8] + cp[10]) * 0.0625 +\n"
"                (cp[5] + cp[9]) * 0.375;\n"
"\n"
"    tessOuterLo = vec4(0);\n"
"    tessOuterHi = vec4(0);\n"
"\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"\n"
"    if ((transitionMask & 8) != 0) {\n"
"        tessOuterLo[0] = OsdComputeTessLevel(vv0, ev03);\n"
"        tessOuterHi[0] = OsdComputeTessLevel(vv3, ev03);\n"
"    } else {\n"
"        tessOuterLo[0] = OsdComputeTessLevel(cp[5], cp[9]);\n"
"    }\n"
"    if ((transitionMask & 1) != 0) {\n"
"        tessOuterLo[1] = OsdComputeTessLevel(vv0, ev01);\n"
"        tessOuterHi[1] = OsdComputeTessLevel(vv1, ev01);\n"
"    } else {\n"
"        tessOuterLo[1] = OsdComputeTessLevel(cp[5], cp[6]);\n"
"    }\n"
"    if ((transitionMask & 2) != 0) {\n"
"        tessOuterLo[2] = OsdComputeTessLevel(vv1, ev12);\n"
"        tessOuterHi[2] = OsdComputeTessLevel(vv2, ev12);\n"
"    } else {\n"
"        tessOuterLo[2] = OsdComputeTessLevel(cp[6], cp[10]);\n"
"    }\n"
"    if ((transitionMask & 4) != 0) {\n"
"        tessOuterLo[3] = OsdComputeTessLevel(vv3, ev23);\n"
"        tessOuterHi[3] = OsdComputeTessLevel(vv2, ev23);\n"
"    } else {\n"
"        tessOuterLo[3] = OsdComputeTessLevel(cp[9], cp[10]);\n"
"    }\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsLimitPoints(OsdPerPatchVertexBezier cpBezier[16],\n"
"                 ivec3 patchParam, out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    // Each edge of a transition patch is adjacent to one or two patches\n"
"    // at the next refined level of subdivision. When the patch control\n"
"    // points have been converted to the Bezier basis, the control points\n"
"    // at the four corners are on the limit surface (since a Bezier patch\n"
"    // interpolates its corner control points). We can compute an adaptive\n"
"    // tessellation level for transition edges on the limit surface by\n"
"    // evaluating a limit position at the mid point of each transition edge.\n"
"\n"
"    tessOuterLo = vec4(0);\n"
"    tessOuterHi = vec4(0);\n"
"\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"\n"
"#if defined OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    // PERFOMANCE: we just need to pick the correct corner points from P, P1, P2\n"
"    vec3 p0 = OsdEvalBezier(cpBezier, patchParam, vec2(0.0, 0.0));\n"
"    vec3 p3 = OsdEvalBezier(cpBezier, patchParam, vec2(1.0, 0.0));\n"
"    vec3 p12 = OsdEvalBezier(cpBezier, patchParam, vec2(0.0, 1.0));\n"
"    vec3 p15 = OsdEvalBezier(cpBezier, patchParam, vec2(1.0, 1.0));\n"
"    if ((transitionMask & 8) != 0) {\n"
"        vec3 ev03 = OsdEvalBezier(cpBezier, patchParam, vec2(0.0, 0.5));\n"
"        tessOuterLo[0] = OsdComputeTessLevel(p0, ev03);\n"
"        tessOuterHi[0] = OsdComputeTessLevel(p12, ev03);\n"
"    } else {\n"
"        tessOuterLo[0] = OsdComputeTessLevel(p0, p12);\n"
"    }\n"
"    if ((transitionMask & 1) != 0) {\n"
"        vec3 ev01 = OsdEvalBezier(cpBezier, patchParam, vec2(0.5, 0.0));\n"
"        tessOuterLo[1] = OsdComputeTessLevel(p0, ev01);\n"
"        tessOuterHi[1] = OsdComputeTessLevel(p3, ev01);\n"
"    } else {\n"
"        tessOuterLo[1] = OsdComputeTessLevel(p0, p3);\n"
"    }\n"
"    if ((transitionMask & 2) != 0) {\n"
"        vec3 ev12 = OsdEvalBezier(cpBezier, patchParam, vec2(1.0, 0.5));\n"
"        tessOuterLo[2] = OsdComputeTessLevel(p3, ev12);\n"
"        tessOuterHi[2] = OsdComputeTessLevel(p15, ev12);\n"
"    } else {\n"
"        tessOuterLo[2] = OsdComputeTessLevel(p3, p15);\n"
"    }\n"
"    if ((transitionMask & 4) != 0) {\n"
"        vec3 ev23 = OsdEvalBezier(cpBezier, patchParam, vec2(0.5, 1.0));\n"
"        tessOuterLo[3] = OsdComputeTessLevel(p12, ev23);\n"
"        tessOuterHi[3] = OsdComputeTessLevel(p15, ev23);\n"
"    } else {\n"
"        tessOuterLo[3] = OsdComputeTessLevel(p12, p15);\n"
"    }\n"
"#else\n"
"    if ((transitionMask & 8) != 0) {\n"
"        vec3 ev03 = OsdEvalBezier(cpBezier, patchParam, vec2(0.0, 0.5));\n"
"        tessOuterLo[0] = OsdComputeTessLevel(cpBezier[0].P, ev03);\n"
"        tessOuterHi[0] = OsdComputeTessLevel(cpBezier[12].P, ev03);\n"
"    } else {\n"
"        tessOuterLo[0] = OsdComputeTessLevel(cpBezier[0].P, cpBezier[12].P);\n"
"    }\n"
"    if ((transitionMask & 1) != 0) {\n"
"        vec3 ev01 = OsdEvalBezier(cpBezier, patchParam, vec2(0.5, 0.0));\n"
"        tessOuterLo[1] = OsdComputeTessLevel(cpBezier[0].P, ev01);\n"
"        tessOuterHi[1] = OsdComputeTessLevel(cpBezier[3].P, ev01);\n"
"    } else {\n"
"        tessOuterLo[1] = OsdComputeTessLevel(cpBezier[0].P, cpBezier[3].P);\n"
"    }\n"
"    if ((transitionMask & 2) != 0) {\n"
"        vec3 ev12 = OsdEvalBezier(cpBezier, patchParam, vec2(1.0, 0.5));\n"
"        tessOuterLo[2] = OsdComputeTessLevel(cpBezier[3].P, ev12);\n"
"        tessOuterHi[2] = OsdComputeTessLevel(cpBezier[15].P, ev12);\n"
"    } else {\n"
"        tessOuterLo[2] = OsdComputeTessLevel(cpBezier[3].P, cpBezier[15].P);\n"
"    }\n"
"    if ((transitionMask & 4) != 0) {\n"
"        vec3 ev23 = OsdEvalBezier(cpBezier, patchParam, vec2(0.5, 1.0));\n"
"        tessOuterLo[3] = OsdComputeTessLevel(cpBezier[12].P, ev23);\n"
"        tessOuterHi[3] = OsdComputeTessLevel(cpBezier[15].P, ev23);\n"
"    } else {\n"
"        tessOuterLo[3] = OsdComputeTessLevel(cpBezier[12].P, cpBezier[15].P);\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"// Round up to the nearest even integer\n"
"float OsdRoundUpEven(float x) {\n"
"    return 2*ceil(x/2);\n"
"}\n"
"\n"
"// Round up to the nearest odd integer\n"
"float OsdRoundUpOdd(float x) {\n"
"    return 2*ceil((x+1)/2)-1;\n"
"}\n"
"\n"
"// Compute outer and inner tessellation levels taking into account the\n"
"// current tessellation spacing mode.\n"
"void\n"
"OsdComputeTessLevels(inout vec4 tessOuterLo, inout vec4 tessOuterHi,\n"
"                     out vec4 tessLevelOuter, out vec2 tessLevelInner)\n"
"{\n"
"    // Outer levels are the sum of the Lo and Hi segments where the Hi\n"
"    // segments will have lengths of zero for non-transition edges.\n"
"\n"
"#if defined OSD_FRACTIONAL_EVEN_SPACING\n"
"    // Combine fractional outer transition edge levels before rounding.\n"
"    vec4 combinedOuter = tessOuterLo + tessOuterHi;\n"
"\n"
"    // Round the segments of transition edges separately. We will recover the\n"
"    // fractional parameterization of transition edges after tessellation.\n"
"\n"
"    tessLevelOuter = combinedOuter;\n"
"    if (tessOuterHi[0] > 0) {\n"
"        tessLevelOuter[0] =\n"
"            OsdRoundUpEven(tessOuterLo[0]) + OsdRoundUpEven(tessOuterHi[0]);\n"
"    }\n"
"    if (tessOuterHi[1] > 0) {\n"
"        tessLevelOuter[1] =\n"
"            OsdRoundUpEven(tessOuterLo[1]) + OsdRoundUpEven(tessOuterHi[1]);\n"
"    }\n"
"    if (tessOuterHi[2] > 0) {\n"
"        tessLevelOuter[2] =\n"
"            OsdRoundUpEven(tessOuterLo[2]) + OsdRoundUpEven(tessOuterHi[2]);\n"
"    }\n"
"    if (tessOuterHi[3] > 0) {\n"
"        tessLevelOuter[3] =\n"
"            OsdRoundUpEven(tessOuterLo[3]) + OsdRoundUpEven(tessOuterHi[3]);\n"
"    }\n"
"#elif defined OSD_FRACTIONAL_ODD_SPACING\n"
"    // Combine fractional outer transition edge levels before rounding.\n"
"    vec4 combinedOuter = tessOuterLo + tessOuterHi;\n"
"\n"
"    // Round the segments of transition edges separately. We will recover the\n"
"    // fractional parameterization of transition edges after tessellation.\n"
"    //\n"
"    // The sum of the two outer odd segment lengths will be an even number\n"
"    // which the tessellator will increase by +1 so that there will be a\n"
"    // total odd number of segments. We clamp the combinedOuter tess levels\n"
"    // (used to compute the inner tess levels) so that the outer transition\n"
"    // edges will be sampled without degenerate triangles.\n"
"\n"
"    tessLevelOuter = combinedOuter;\n"
"    if (tessOuterHi[0] > 0) {\n"
"        tessLevelOuter[0] =\n"
"            OsdRoundUpOdd(tessOuterLo[0]) + OsdRoundUpOdd(tessOuterHi[0]);\n"
"        combinedOuter = max(vec4(3), combinedOuter);\n"
"    }\n"
"    if (tessOuterHi[1] > 0) {\n"
"        tessLevelOuter[1] =\n"
"            OsdRoundUpOdd(tessOuterLo[1]) + OsdRoundUpOdd(tessOuterHi[1]);\n"
"        combinedOuter = max(vec4(3), combinedOuter);\n"
"    }\n"
"    if (tessOuterHi[2] > 0) {\n"
"        tessLevelOuter[2] =\n"
"            OsdRoundUpOdd(tessOuterLo[2]) + OsdRoundUpOdd(tessOuterHi[2]);\n"
"        combinedOuter = max(vec4(3), combinedOuter);\n"
"    }\n"
"    if (tessOuterHi[3] > 0) {\n"
"        tessLevelOuter[3] =\n"
"            OsdRoundUpOdd(tessOuterLo[3]) + OsdRoundUpOdd(tessOuterHi[3]);\n"
"        combinedOuter = max(vec4(3), combinedOuter);\n"
"    }\n"
"#else\n"
"    // Round equally spaced transition edge levels before combining.\n"
"    tessOuterLo = round(tessOuterLo);\n"
"    tessOuterHi = round(tessOuterHi);\n"
"\n"
"    vec4 combinedOuter = tessOuterLo + tessOuterHi;\n"
"    tessLevelOuter = combinedOuter;\n"
"#endif\n"
"\n"
"    // Inner levels are the averages the corresponding outer levels.\n"
"    tessLevelInner[0] = (combinedOuter[1] + combinedOuter[3]) * 0.5;\n"
"    tessLevelInner[1] = (combinedOuter[0] + combinedOuter[2]) * 0.5;\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsUniform(ivec3 patchParam,\n"
"                 out vec4 tessLevelOuter, out vec2 tessLevelInner,\n"
"                 out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    // uniform tessellation\n"
"    OsdGetTessLevelsUniform(patchParam, tessOuterLo, tessOuterHi);\n"
"\n"
"    OsdComputeTessLevels(tessOuterLo, tessOuterHi,\n"
"                         tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsAdaptiveRefinedPoints(vec3 cpRefined[16], ivec3 patchParam,\n"
"                        out vec4 tessLevelOuter, out vec2 tessLevelInner,\n"
"                        out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    OsdGetTessLevelsRefinedPoints(cpRefined, patchParam,\n"
"                                  tessOuterLo, tessOuterHi);\n"
"\n"
"    OsdComputeTessLevels(tessOuterLo, tessOuterHi,\n"
"                         tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsAdaptiveLimitPoints(OsdPerPatchVertexBezier cpBezier[16],\n"
"                 ivec3 patchParam,\n"
"                 out vec4 tessLevelOuter, out vec2 tessLevelInner,\n"
"                 out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    OsdGetTessLevelsLimitPoints(cpBezier, patchParam,\n"
"                                tessOuterLo, tessOuterHi);\n"
"\n"
"    OsdComputeTessLevels(tessOuterLo, tessOuterHi,\n"
"                         tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevels(vec3 cp0, vec3 cp1, vec3 cp2, vec3 cp3,\n"
"                 ivec3 patchParam,\n"
"                 out vec4 tessLevelOuter, out vec2 tessLevelInner)\n"
"{\n"
"    vec4 tessOuterLo = vec4(0);\n"
"    vec4 tessOuterHi = vec4(0);\n"
"\n"
"#if defined OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"    tessOuterLo[0] = OsdComputeTessLevel(cp0, cp1);\n"
"    tessOuterLo[1] = OsdComputeTessLevel(cp0, cp3);\n"
"    tessOuterLo[2] = OsdComputeTessLevel(cp2, cp3);\n"
"    tessOuterLo[3] = OsdComputeTessLevel(cp1, cp2);\n"
"    tessOuterHi = vec4(0);\n"
"#else\n"
"    OsdGetTessLevelsUniform(patchParam, tessOuterLo, tessOuterHi);\n"
"#endif\n"
"\n"
"    OsdComputeTessLevels(tessOuterLo, tessOuterHi,\n"
"                         tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"#if defined OSD_FRACTIONAL_EVEN_SPACING || defined OSD_FRACTIONAL_ODD_SPACING\n"
"float\n"
"OsdGetTessFractionalSplit(float t, float level, float levelUp)\n"
"{\n"
"    // Fractional tessellation of an edge will produce n segments where n\n"
"    // is the tessellation level of the edge (level) rounded up to the\n"
"    // nearest even or odd integer (levelUp). There will be n-2 segments of\n"
"    // equal length (dx1) and two additional segments of equal length (dx0)\n"
"    // that are typically shorter than the other segments. The two additional\n"
"    // segments should be placed symmetrically on opposite sides of the\n"
"    // edge (offset).\n"
"\n"
"#if defined OSD_FRACTIONAL_EVEN_SPACING\n"
"    if (level <= 2) return t;\n"
"\n"
"    float base = pow(2.0,floor(log2(levelUp)));\n"
"    float offset = 1.0/(int(2*base-levelUp)/2 & int(base/2-1));\n"
"\n"
"#elif defined OSD_FRACTIONAL_ODD_SPACING\n"
"    if (level <= 1) return t;\n"
"\n"
"    float base = pow(2.0,floor(log2(levelUp)));\n"
"    float offset = 1.0/(((int(2*base-levelUp)/2+1) & int(base/2-1))+1);\n"
"#endif\n"
"\n"
"    float dx0 = (1.0 - (levelUp-level)/2) / levelUp;\n"
"    float dx1 = (1.0 - 2.0*dx0) / (levelUp - 2.0*ceil(dx0));\n"
"\n"
"    if (t < 0.5) {\n"
"        float x = levelUp/2 - round(t*levelUp);\n"
"        return 0.5 - (x*dx1 + int(x*offset > 1) * (dx0 - dx1));\n"
"    } else if (t > 0.5) {\n"
"        float x = round(t*levelUp) - levelUp/2;\n"
"        return 0.5 + (x*dx1 + int(x*offset > 1) * (dx0 - dx1));\n"
"    } else {\n"
"        return t;\n"
"    }\n"
"}\n"
"#endif\n"
"\n"
"float\n"
"OsdGetTessTransitionSplit(float t, float lo, float hi)\n"
"{\n"
"#if defined OSD_FRACTIONAL_EVEN_SPACING\n"
"    float loRoundUp = OsdRoundUpEven(lo);\n"
"    float hiRoundUp = OsdRoundUpEven(hi);\n"
"\n"
"    // Convert the parametric t into a segment index along the combined edge.\n"
"    float ti = round(t * (loRoundUp + hiRoundUp));\n"
"\n"
"    if (ti <= loRoundUp) {\n"
"        float t0 = ti / loRoundUp;\n"
"        return OsdGetTessFractionalSplit(t0, lo, loRoundUp) * 0.5;\n"
"    } else {\n"
"        float t1 = (ti - loRoundUp) / hiRoundUp;\n"
"        return OsdGetTessFractionalSplit(t1, hi, hiRoundUp) * 0.5 + 0.5;\n"
"    }\n"
"#elif defined OSD_FRACTIONAL_ODD_SPACING\n"
"    float loRoundUp = OsdRoundUpOdd(lo);\n"
"    float hiRoundUp = OsdRoundUpOdd(hi);\n"
"\n"
"    // Convert the parametric t into a segment index along the combined edge.\n"
"    // The +1 below is to account for the extra segment produced by the\n"
"    // tessellator since the sum of two odd tess levels will be rounded\n"
"    // up by one to the next odd integer tess level.\n"
"    float ti = round(t * (loRoundUp + hiRoundUp + 1));\n"
"\n"
"    if (ti <= loRoundUp) {\n"
"        float t0 = ti / loRoundUp;\n"
"        return OsdGetTessFractionalSplit(t0, lo, loRoundUp) * 0.5;\n"
"    } else if (ti > (loRoundUp+1)) {\n"
"        float t1 = (ti - (loRoundUp+1)) / hiRoundUp;\n"
"        return OsdGetTessFractionalSplit(t1, hi, hiRoundUp) * 0.5 + 0.5;\n"
"    } else {\n"
"        return 0.5;\n"
"    }\n"
"#else\n"
"    // Convert the parametric t into a segment index along the combined edge.\n"
"    float ti = round(t * (lo + hi));\n"
"\n"
"    if (ti <= lo) {\n"
"        return (ti / lo) * 0.5;\n"
"    } else {\n"
"        return ((ti - lo) / hi) * 0.5 + 0.5;\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"vec2\n"
"OsdGetTessParameterization(vec2 uv, vec4 tessOuterLo, vec4 tessOuterHi)\n"
"{\n"
"    vec2 UV = uv;\n"
"    if (UV.x == 0 && tessOuterHi[0] > 0) {\n"
"        UV.y = OsdGetTessTransitionSplit(UV.y, tessOuterLo[0], tessOuterHi[0]);\n"
"    } else\n"
"    if (UV.y == 0 && tessOuterHi[1] > 0) {\n"
"        UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[1], tessOuterHi[1]);\n"
"    } else\n"
"    if (UV.x == 1 && tessOuterHi[2] > 0) {\n"
"        UV.y = OsdGetTessTransitionSplit(UV.y, tessOuterLo[2], tessOuterHi[2]);\n"
"    } else\n"
"    if (UV.y == 1 && tessOuterHi[3] > 0) {\n"
"        UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[3], tessOuterHi[3]);\n"
"    }\n"
"    return UV;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// BSpline\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"// compute single-crease patch matrix\n"
"mat4\n"
"OsdComputeMs(float sharpness)\n"
"{\n"
"    float s = pow(2.0f, sharpness);\n"
"    float s2 = s*s;\n"
"    float s3 = s2*s;\n"
"\n"
"    mat4 m = mat4(\n"
"        0, s + 1 + 3*s2 - s3, 7*s - 2 - 6*s2 + 2*s3, (1-s)*(s-1)*(s-1),\n"
"        0,       (1+s)*(1+s),        6*s - 2 - 2*s2,       (s-1)*(s-1),\n"
"        0,               1+s,               6*s - 2,               1-s,\n"
"        0,                 1,               6*s - 2,                 1);\n"
"\n"
"    m /= (s*6.0);\n"
"    m[0][0] = 1.0/6.0;\n"
"\n"
"    return m;\n"
"}\n"
"\n"
"// flip matrix orientation\n"
"mat4\n"
"OsdFlipMatrix(mat4 m)\n"
"{\n"
"    return mat4(m[3][3], m[3][2], m[3][1], m[3][0],\n"
"                m[2][3], m[2][2], m[2][1], m[2][0],\n"
"                m[1][3], m[1][2], m[1][1], m[1][0],\n"
"                m[0][3], m[0][2], m[0][1], m[0][0]);\n"
"}\n"
"\n"
"// Regular BSpline to Bezier\n"
"uniform mat4 Q = mat4(\n"
"    1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f,\n"
"    0.f,     4.f/6.f, 2.f/6.f, 0.f,\n"
"    0.f,     2.f/6.f, 4.f/6.f, 0.f,\n"
"    0.f,     1.f/6.f, 4.f/6.f, 1.f/6.f\n"
");\n"
"\n"
"// Infinitely Sharp (boundary)\n"
"uniform mat4 Mi = mat4(\n"
"    1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f,\n"
"    0.f,     4.f/6.f, 2.f/6.f, 0.f,\n"
"    0.f,     2.f/6.f, 4.f/6.f, 0.f,\n"
"    0.f,     0.f,     1.f,     0.f\n"
");\n"
"\n"
"// convert BSpline cv to Bezier cv\n"
"void\n"
"OsdComputePerPatchVertexBSpline(ivec3 patchParam, int ID, vec3 cv[16],\n"
"                                out OsdPerPatchVertexBezier result)\n"
"{\n"
"    result.patchParam = patchParam;\n"
"\n"
"    int i = ID%4;\n"
"    int j = ID/4;\n"
"\n"
"#if defined OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"\n"
"    vec3 P  = vec3(0); // 0 to 1-2^(-Sf)\n"
"    vec3 P1 = vec3(0); // 1-2^(-Sf) to 1-2^(-Sc)\n"
"    vec3 P2 = vec3(0); // 1-2^(-Sc) to 1\n"
"\n"
"    float sharpness = OsdGetPatchSharpness(patchParam);\n"
"    if (sharpness > 0) {\n"
"        float Sf = floor(sharpness);\n"
"        float Sc = ceil(sharpness);\n"
"        float Sr = fract(sharpness);\n"
"        mat4 Mf = OsdComputeMs(Sf);\n"
"        mat4 Mc = OsdComputeMs(Sc);\n"
"        mat4 Mj = (1-Sr) * Mf + Sr * Mi;\n"
"        mat4 Ms = (1-Sr) * Mf + Sr * Mc;\n"
"        float s0 = 1 - pow(2, -floor(sharpness));\n"
"        float s1 = 1 - pow(2, -ceil(sharpness));\n"
"        result.vSegments = vec2(s0, s1);\n"
"\n"
"        mat4 MUi = Q, MUj = Q, MUs = Q;\n"
"        mat4 MVi = Q, MVj = Q, MVs = Q;\n"
"\n"
"        int boundaryMask = OsdGetPatchBoundaryMask(patchParam);\n"
"        if ((boundaryMask & 1) != 0) {\n"
"            MVi = OsdFlipMatrix(Mi);\n"
"            MVj = OsdFlipMatrix(Mj);\n"
"            MVs = OsdFlipMatrix(Ms);\n"
"        }\n"
"        if ((boundaryMask & 2) != 0) {\n"
"            MUi = Mi;\n"
"            MUj = Mj;\n"
"            MUs = Ms;\n"
"        }\n"
"        if ((boundaryMask & 4) != 0) {\n"
"            MVi = Mi;\n"
"            MVj = Mj;\n"
"            MVs = Ms;\n"
"        }\n"
"        if ((boundaryMask & 8) != 0) {\n"
"            MUi = OsdFlipMatrix(Mi);\n"
"            MUj = OsdFlipMatrix(Mj);\n"
"            MUs = OsdFlipMatrix(Ms);\n"
"        }\n"
"\n"
"        vec3 Hi[4], Hj[4], Hs[4];\n"
"        for (int l=0; l<4; ++l) {\n"
"            Hi[l] = Hj[l] = Hs[l] = vec3(0);\n"
"            for (int k=0; k<4; ++k) {\n"
"                Hi[l] += MUi[i][k] * cv[l*4 + k];\n"
"                Hj[l] += MUj[i][k] * cv[l*4 + k];\n"
"                Hs[l] += MUs[i][k] * cv[l*4 + k];\n"
"            }\n"
"        }\n"
"        for (int k=0; k<4; ++k) {\n"
"            P  += MVi[j][k]*Hi[k];\n"
"            P1 += MVj[j][k]*Hj[k];\n"
"            P2 += MVs[j][k]*Hs[k];\n"
"        }\n"
"\n"
"        result.P  = P;\n"
"        result.P1 = P1;\n"
"        result.P2 = P2;\n"
"    } else {\n"
"        result.vSegments = vec2(0);\n"
"\n"
"        OsdComputeBSplineBoundaryPoints(cv, patchParam);\n"
"\n"
"        vec3 Hi[4];\n"
"        for (int l=0; l<4; ++l) {\n"
"            Hi[l] = vec3(0);\n"
"            for (int k=0; k<4; ++k) {\n"
"                Hi[l] += Q[i][k] * cv[l*4 + k];\n"
"            }\n"
"        }\n"
"        for (int k=0; k<4; ++k) {\n"
"            P += Q[j][k]*Hi[k];\n"
"        }\n"
"\n"
"        result.P  = P;\n"
"        result.P1 = P;\n"
"        result.P2 = P;\n"
"    }\n"
"#else\n"
"    OsdComputeBSplineBoundaryPoints(cv, patchParam);\n"
"\n"
"    vec3 H[4];\n"
"    for (int l=0; l<4; ++l) {\n"
"        H[l] = vec3(0);\n"
"        for (int k=0; k<4; ++k) {\n"
"            H[l] += Q[i][k] * cv[l*4 + k];\n"
"        }\n"
"    }\n"
"    {\n"
"        result.P = vec3(0);\n"
"        for (int k=0; k<4; ++k) {\n"
"            result.P += Q[j][k]*H[k];\n"
"        }\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchBezier(ivec3 patchParam, vec2 UV,\n"
"                   OsdPerPatchVertexBezier cv[16],\n"
"                   out vec3 P, out vec3 dPu, out vec3 dPv,\n"
"                   out vec3 N, out vec3 dNu, out vec3 dNv)\n"
"{\n"
"    //\n"
"    //  Use the recursive nature of the basis functions to compute a 2x2 set\n"
"    //  of intermediate points (via repeated linear interpolation).  These\n"
"    //  points define a bilinear surface tangent to the desired surface at P\n"
"    //  and so containing dPu and dPv.  The cost of computing P, dPu and dPv\n"
"    //  this way is comparable to that of typical tensor product evaluation\n"
"    //  (if not faster).\n"
"    //\n"
"    //  If N = dPu X dPv degenerates, it often results from an edge of the\n"
"    //  2x2 bilinear hull collapsing or two adjacent edges colinear. In both\n"
"    //  cases, the expected non-planar quad degenerates into a triangle, and\n"
"    //  the tangent plane of that triangle provides the desired normal N.\n"
"    //\n"
"\n"
"    //  Reduce 4x4 points to 2x4 -- two levels of linear interpolation in U\n"
"    //  and so 3 original rows contributing to each of the 2 resulting rows:\n"
"    float u    = UV.x;\n"
"    float uinv = 1.0f - u;\n"
"\n"
"    float u0 = uinv * uinv;\n"
"    float u1 = u * uinv * 2.0f;\n"
"    float u2 = u * u;\n"
"\n"
"    vec3 LROW[4], RROW[4];\n"
"#ifndef OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    LROW[0] = u0 * cv[ 0].P + u1 * cv[ 1].P + u2 * cv[ 2].P;\n"
"    LROW[1] = u0 * cv[ 4].P + u1 * cv[ 5].P + u2 * cv[ 6].P;\n"
"    LROW[2] = u0 * cv[ 8].P + u1 * cv[ 9].P + u2 * cv[10].P;\n"
"    LROW[3] = u0 * cv[12].P + u1 * cv[13].P + u2 * cv[14].P;\n"
"\n"
"    RROW[0] = u0 * cv[ 1].P + u1 * cv[ 2].P + u2 * cv[ 3].P;\n"
"    RROW[1] = u0 * cv[ 5].P + u1 * cv[ 6].P + u2 * cv[ 7].P;\n"
"    RROW[2] = u0 * cv[ 9].P + u1 * cv[10].P + u2 * cv[11].P;\n"
"    RROW[3] = u0 * cv[13].P + u1 * cv[14].P + u2 * cv[15].P;\n"
"#else\n"
"    vec2 vSegments = cv[0].vSegments;\n"
"    float s = OsdGetPatchSingleCreaseSegmentParameter(patchParam, UV);\n"
"\n"
"    for (int i = 0; i < 4; ++i) {\n"
"        int j = i*4;\n"
"        if (s <= vSegments.x) {\n"
"            LROW[i] = u0 * cv[ j ].P + u1 * cv[j+1].P + u2 * cv[j+2].P;\n"
"            RROW[i] = u0 * cv[j+1].P + u1 * cv[j+2].P + u2 * cv[j+3].P;\n"
"        } else if (s <= vSegments.y) {\n"
"            LROW[i] = u0 * cv[ j ].P1 + u1 * cv[j+1].P1 + u2 * cv[j+2].P1;\n"
"            RROW[i] = u0 * cv[j+1].P1 + u1 * cv[j+2].P1 + u2 * cv[j+3].P1;\n"
"        } else {\n"
"            LROW[i] = u0 * cv[ j ].P2 + u1 * cv[j+1].P2 + u2 * cv[j+2].P2;\n"
"            RROW[i] = u0 * cv[j+1].P2 + u1 * cv[j+2].P2 + u2 * cv[j+3].P2;\n"
"        }\n"
"    }\n"
"#endif\n"
"\n"
"    //  Reduce 2x4 points to 2x2 -- two levels of linear interpolation in V\n"
"    //  and so 3 original pairs contributing to each of the 2 resulting:\n"
"    float v    = UV.y;\n"
"    float vinv = 1.0f - v;\n"
"\n"
"    float v0 = vinv * vinv;\n"
"    float v1 = v * vinv * 2.0f;\n"
"    float v2 = v * v;\n"
"\n"
"    vec3 LPAIR[2], RPAIR[2];\n"
"    LPAIR[0] = v0 * LROW[0] + v1 * LROW[1] + v2 * LROW[2];\n"
"    RPAIR[0] = v0 * RROW[0] + v1 * RROW[1] + v2 * RROW[2];\n"
"\n"
"    LPAIR[1] = v0 * LROW[1] + v1 * LROW[2] + v2 * LROW[3];\n"
"    RPAIR[1] = v0 * RROW[1] + v1 * RROW[2] + v2 * RROW[3];\n"
"\n"
"    //  Interpolate points on the edges of the 2x2 bilinear hull from which\n"
"    //  both position and partials are trivially determined:\n"
"    vec3 DU0 = vinv * LPAIR[0] + v * LPAIR[1];\n"
"    vec3 DU1 = vinv * RPAIR[0] + v * RPAIR[1];\n"
"    vec3 DV0 = uinv * LPAIR[0] + u * RPAIR[0];\n"
"    vec3 DV1 = uinv * LPAIR[1] + u * RPAIR[1];\n"
"\n"
"    int level = OsdGetPatchFaceLevel(patchParam);\n"
"    dPu = (DU1 - DU0) * 3 * level;\n"
"    dPv = (DV1 - DV0) * 3 * level;\n"
"\n"
"    P = u * DU1 + uinv * DU0;\n"
"\n"
"    //  Compute the normal and test for degeneracy:\n"
"    //\n"
"    //  We need a geometric measure of the size of the patch for a suitable\n"
"    //  tolerance.  Magnitudes of the partials are generally proportional to\n"
"    //  that size -- the sum of the partials is readily available, cheap to\n"
"    //  compute, and has proved effective in most cases (though not perfect).\n"
"    //  The size of the bounding box of the patch, or some approximation to\n"
"    //  it, would be better but more costly to compute.\n"
"    //\n"
"    float proportionalNormalTolerance = 0.00001f;\n"
"\n"
"    float nEpsilon = (length(dPu) + length(dPv)) * proportionalNormalTolerance;\n"
"\n"
"    N = cross(dPu, dPv);\n"
"\n"
"    float nLength = length(N);\n"
"    if (nLength > nEpsilon) {\n"
"        N = N / nLength;\n"
"    } else {\n"
"        vec3 diagCross = cross(RPAIR[1] - LPAIR[0], LPAIR[1] - RPAIR[0]);\n"
"        float diagCrossLength = length(diagCross);\n"
"        if (diagCrossLength > nEpsilon) {\n"
"            N = diagCross / diagCrossLength;\n"
"        }\n"
"    }\n"
"\n"
"#ifndef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    dNu = vec3(0);\n"
"    dNv = vec3(0);\n"
"#else\n"
"    //\n"
"    //  Compute 2nd order partials of P(u,v) in order to compute 1st order partials\n"
"    //  for the un-normalized n(u,v) = dPu X dPv, then project into the tangent\n"
"    //  plane of normalized N.  With resulting dNu and dNv we can make another\n"
"    //  attempt to resolve a still-degenerate normal.\n"
"    //\n"
"    //  We don't use the Weingarten equations here as they require N != 0 and also\n"
"    //  are a little less numerically stable/accurate in single precision.\n"
"    //\n"
"    float B0u[4], B1u[4], B2u[4];\n"
"    float B0v[4], B1v[4], B2v[4];\n"
"\n"
"    OsdUnivar4x4(UV.x, B0u, B1u, B2u);\n"
"    OsdUnivar4x4(UV.y, B0v, B1v, B2v);\n"
"\n"
"    vec3 dUU = vec3(0);\n"
"    vec3 dVV = vec3(0);\n"
"    vec3 dUV = vec3(0);\n"
"\n"
"    for (int i=0; i<4; ++i) {\n"
"        for (int j=0; j<4; ++j) {\n"
"#ifdef OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"            int k = 4*i + j;\n"
"            vec3 CV = (s <= vSegments.x) ? cv[k].P\n"
"                 :   ((s <= vSegments.y) ? cv[k].P1\n"
"                                         : cv[k].P2);\n"
"#else\n"
"            vec3 CV = cv[4*i + j].P;\n"
"#endif\n"
"            dUU += (B0v[i] * B2u[j]) * CV;\n"
"            dVV += (B2v[i] * B0u[j]) * CV;\n"
"            dUV += (B1v[i] * B1u[j]) * CV;\n"
"        }\n"
"    }\n"
"\n"
"    dUU *= 6 * level;\n"
"    dVV *= 6 * level;\n"
"    dUV *= 9 * level;\n"
"\n"
"    dNu = cross(dUU, dPv) + cross(dPu, dUV);\n"
"    dNv = cross(dUV, dPv) + cross(dPu, dVV);\n"
"\n"
"    float nLengthInv = 1.0;\n"
"    if (nLength > nEpsilon) {\n"
"        nLengthInv = 1.0 / nLength;\n"
"    } else {\n"
"        //  N may have been resolved above if degenerate, but if N was resolved\n"
"        //  we don't have an accurate length for its un-normalized value, and that\n"
"        //  length is needed to project the un-normalized dNu and dNv into the\n"
"        //  tangent plane of N.\n"
"        //\n"
"        //  So compute N more accurately with available second derivatives, i.e.\n"
"        //  with a 1st order Taylor approximation to un-normalized N(u,v).\n"
"\n"
"        float DU = (UV.x == 1.0f) ? -1.0f : 1.0f;\n"
"        float DV = (UV.y == 1.0f) ? -1.0f : 1.0f;\n"
"\n"
"        N = DU * dNu + DV * dNv;\n"
"\n"
"        nLength = length(N);\n"
"        if (nLength > nEpsilon) {\n"
"            nLengthInv = 1.0f / nLength;\n"
"            N = N * nLengthInv;\n"
"        }\n"
"    }\n"
"\n"
"    //  Project derivatives of non-unit normals into tangent plane of N:\n"
"    dNu = (dNu - dot(dNu,N) * N) * nLengthInv;\n"
"    dNv = (dNv - dot(dNv,N) * N) * nLengthInv;\n"
"#endif\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Gregory Basis\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"struct OsdPerPatchVertexGregoryBasis {\n"
"    ivec3 patchParam;\n"
"    vec3 P;\n"
"};\n"
"\n"
"void\n"
"OsdComputePerPatchVertexGregoryBasis(ivec3 patchParam, int ID, vec3 cv,\n"
"                                     out OsdPerPatchVertexGregoryBasis result)\n"
"{\n"
"    result.patchParam = patchParam;\n"
"    result.P = cv;\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchGregory(ivec3 patchParam, vec2 UV, vec3 cv[20],\n"
"                    out vec3 P, out vec3 dPu, out vec3 dPv,\n"
"                    out vec3 N, out vec3 dNu, out vec3 dNv)\n"
"{\n"
"    float u = UV.x, v = UV.y;\n"
"    float U = 1-u, V = 1-v;\n"
"\n"
"    //(0,1)                              (1,1)\n"
"    //   P3         e3-      e2+         P2\n"
"    //      15------17-------11-------10\n"
"    //      |        |        |        |\n"
"    //      |        |        |        |\n"
"    //      |        | f3-    | f2+    |\n"
"    //      |       19       13        |\n"
"    //  e3+ 16-----18          14-----12 e2-\n"
"    //      |     f3+          f2-     |\n"
"    //      |                          |\n"
"    //      |                          |\n"
"    //      |     f0-         f1+      |\n"
"    //  e0- 2------4            8------6 e1+\n"
"    //      |        3 f0+    9        |\n"
"    //      |        |        | f1-    |\n"
"    //      |        |        |        |\n"
"    //      |        |        |        |\n"
"    //      0--------1--------7--------5\n"
"    //    P0        e0+      e1-         P1\n"
"    //(0,0)                               (1,0)\n"
"\n"
"    float d11 = u+v;\n"
"    float d12 = U+v;\n"
"    float d21 = u+V;\n"
"    float d22 = U+V;\n"
"\n"
"    OsdPerPatchVertexBezier bezcv[16];\n"
"\n"
"    bezcv[ 5].P = (d11 == 0.0) ? cv[3]  : (u*cv[3] + v*cv[4])/d11;\n"
"    bezcv[ 6].P = (d12 == 0.0) ? cv[8]  : (U*cv[9] + v*cv[8])/d12;\n"
"    bezcv[ 9].P = (d21 == 0.0) ? cv[18] : (u*cv[19] + V*cv[18])/d21;\n"
"    bezcv[10].P = (d22 == 0.0) ? cv[13] : (U*cv[13] + V*cv[14])/d22;\n"
"\n"
"    bezcv[ 0].P = cv[0];\n"
"    bezcv[ 1].P = cv[1];\n"
"    bezcv[ 2].P = cv[7];\n"
"    bezcv[ 3].P = cv[5];\n"
"    bezcv[ 4].P = cv[2];\n"
"    bezcv[ 7].P = cv[6];\n"
"    bezcv[ 8].P = cv[16];\n"
"    bezcv[11].P = cv[12];\n"
"    bezcv[12].P = cv[15];\n"
"    bezcv[13].P = cv[17];\n"
"    bezcv[14].P = cv[11];\n"
"    bezcv[15].P = cv[10];\n"
"\n"
"    OsdEvalPatchBezier(patchParam, UV, bezcv, P, dPu, dPv, N, dNu, dNv);\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Legacy Gregory\n"
"// ----------------------------------------------------------------------------\n"
"#if defined(OSD_PATCH_GREGORY) || defined(OSD_PATCH_GREGORY_BOUNDARY)\n"
"\n"
"// precomputed catmark coefficient table up to valence 29\n"
"uniform float OsdCatmarkCoefficient[30] = float[](\n"
"    0, 0, 0, 0.812816, 0.500000, 0.363644, 0.287514,\n"
"    0.238688, 0.204544, 0.179229, 0.159657,\n"
"    0.144042, 0.131276, 0.120632, 0.111614,\n"
"    0.103872, 0.09715, 0.0912559, 0.0860444,\n"
"    0.0814022, 0.0772401, 0.0734867, 0.0700842,\n"
"    0.0669851, 0.0641504, 0.0615475, 0.0591488,\n"
"    0.0569311, 0.0548745, 0.0529621\n"
"    );\n"
"\n"
"float\n"
"OsdComputeCatmarkCoefficient(int valence)\n"
"{\n"
"#if OSD_MAX_VALENCE < 30\n"
"    return OsdCatmarkCoefficient[valence];\n"
"#else\n"
"    if (valence < 30) {\n"
"        return OsdCatmarkCoefficient[valence];\n"
"    } else {\n"
"        float t = 2.0f * float(M_PI) / float(valence);\n"
"        return 1.0f / (valence * (cos(t) + 5.0f +\n"
"                                  sqrt((cos(t) + 9) * (cos(t) + 1)))/16.0f);\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"\n"
"float cosfn(int n, int j) {\n"
"    return cos((2.0f * M_PI * j)/float(n));\n"
"}\n"
"\n"
"float sinfn(int n, int j) {\n"
"    return sin((2.0f * M_PI * j)/float(n));    \n"
"}\n"
"\n"
"#if !defined OSD_MAX_VALENCE || OSD_MAX_VALENCE < 1\n"
"#undef OSD_MAX_VALENCE\n"
"#define OSD_MAX_VALENCE 4\n"
"#endif\n"
"\n"
"struct OsdPerVertexGregory {\n"
"    vec3 P;\n"
"    ivec3 clipFlag;\n"
"    int  valence;\n"
"    vec3 e0;\n"
"    vec3 e1;\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    int zerothNeighbor;\n"
"    vec3 org;\n"
"#endif\n"
"    vec3 r[OSD_MAX_VALENCE];\n"
"};\n"
"\n"
"struct OsdPerPatchVertexGregory {\n"
"    ivec3 patchParam;\n"
"    vec3 P;\n"
"    vec3 Ep;\n"
"    vec3 Em;\n"
"    vec3 Fp;\n"
"    vec3 Fm;\n"
"};\n"
"\n"
"#ifndef OSD_NUM_ELEMENTS\n"
"#define OSD_NUM_ELEMENTS 3\n"
"#endif\n"
"\n"
"uniform samplerBuffer OsdVertexBuffer;\n"
"uniform isamplerBuffer OsdValenceBuffer;\n"
"\n"
"vec3 OsdReadVertex(int vertexIndex)\n"
"{\n"
"    int index = int(OSD_NUM_ELEMENTS * (vertexIndex + OsdBaseVertex()));\n"
"    return vec3(texelFetch(OsdVertexBuffer, index).x,\n"
"                texelFetch(OsdVertexBuffer, index+1).x,\n"
"                texelFetch(OsdVertexBuffer, index+2).x);\n"
"}\n"
"\n"
"int OsdReadVertexValence(int vertexID)\n"
"{\n"
"    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1));\n"
"    return texelFetch(OsdValenceBuffer, index).x;\n"
"}\n"
"\n"
"int OsdReadVertexIndex(int vertexID, int valenceVertex)\n"
"{\n"
"    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1) + 1 + valenceVertex);\n"
"    return texelFetch(OsdValenceBuffer, index).x;\n"
"}\n"
"\n"
"uniform isamplerBuffer OsdQuadOffsetBuffer;\n"
"\n"
"int OsdReadQuadOffset(int primitiveID, int offsetVertex)\n"
"{\n"
"    int index = int(4*primitiveID+OsdGregoryQuadOffsetBase() + offsetVertex);\n"
"    return texelFetch(OsdQuadOffsetBuffer, index).x;\n"
"}\n"
"\n"
"void\n"
"OsdComputePerVertexGregory(int vID, vec3 P, out OsdPerVertexGregory v)\n"
"{\n"
"    v.clipFlag = ivec3(0);\n"
"\n"
"    int ivalence = OsdReadVertexValence(vID);\n"
"    v.valence = ivalence;\n"
"    int valence = abs(ivalence);\n"
"\n"
"    vec3 f[OSD_MAX_VALENCE];\n"
"    vec3 pos = P;\n"
"    vec3 opos = vec3(0);\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    v.org = pos;\n"
"    int boundaryEdgeNeighbors[2];\n"
"    int currNeighbor = 0;\n"
"    int ibefore = 0;\n"
"    int zerothNeighbor = 0;\n"
"#endif\n"
"\n"
"    for (int i=0; i<valence; ++i) {\n"
"        int im = (i+valence-1)%valence;\n"
"        int ip = (i+1)%valence;\n"
"\n"
"        int idx_neighbor = OsdReadVertexIndex(vID, 2*i);\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"        bool isBoundaryNeighbor = false;\n"
"        int valenceNeighbor = OsdReadVertexValence(idx_neighbor);\n"
"\n"
"        if (valenceNeighbor < 0) {\n"
"            isBoundaryNeighbor = true;\n"
"            if (currNeighbor<2) {\n"
"                boundaryEdgeNeighbors[currNeighbor] = idx_neighbor;\n"
"            }\n"
"            currNeighbor++;\n"
"            if (currNeighbor == 1) {\n"
"                ibefore = i;\n"
"                zerothNeighbor = i;\n"
"            } else {\n"
"                if (i-ibefore == 1) {\n"
"                    int tmp = boundaryEdgeNeighbors[0];\n"
"                    boundaryEdgeNeighbors[0] = boundaryEdgeNeighbors[1];\n"
"                    boundaryEdgeNeighbors[1] = tmp;\n"
"                    zerothNeighbor = i;\n"
"                }\n"
"            }\n"
"        }\n"
"#endif\n"
"\n"
"        vec3 neighbor = OsdReadVertex(idx_neighbor);\n"
"\n"
"        int idx_diagonal = OsdReadVertexIndex(vID, 2*i + 1);\n"
"        vec3 diagonal = OsdReadVertex(idx_diagonal);\n"
"\n"
"        int idx_neighbor_p = OsdReadVertexIndex(vID, 2*ip);\n"
"        vec3 neighbor_p = OsdReadVertex(idx_neighbor_p);\n"
"\n"
"        int idx_neighbor_m = OsdReadVertexIndex(vID, 2*im);\n"
"        vec3 neighbor_m = OsdReadVertex(idx_neighbor_m);\n"
"\n"
"        int idx_diagonal_m = OsdReadVertexIndex(vID, 2*im + 1);\n"
"        vec3 diagonal_m = OsdReadVertex(idx_diagonal_m);\n"
"\n"
"        f[i] = (pos * float(valence) + (neighbor_p + neighbor)*2.0f + diagonal) / (float(valence)+5.0f);\n"
"\n"
"        opos += f[i];\n"
"        v.r[i] = (neighbor_p-neighbor_m)/3.0f + (diagonal - diagonal_m)/6.0f;\n"
"    }\n"
"\n"
"    opos /= valence;\n"
"    v.P = vec4(opos, 1.0f).xyz;\n"
"\n"
"    vec3 e;\n"
"    v.e0 = vec3(0);\n"
"    v.e1 = vec3(0);\n"
"\n"
"    for(int i=0; i<valence; ++i) {\n"
"        int im = (i + valence -1) % valence;\n"
"        e = 0.5f * (f[i] + f[im]);\n"
"        v.e0 += cosfn(valence, i)*e;\n"
"        v.e1 += sinfn(valence, i)*e;\n"
"    }\n"
"    float ef = OsdComputeCatmarkCoefficient(valence);\n"
"    v.e0 *= ef;\n"
"    v.e1 *= ef;\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    v.zerothNeighbor = zerothNeighbor;\n"
"    if (currNeighbor == 1) {\n"
"        boundaryEdgeNeighbors[1] = boundaryEdgeNeighbors[0];\n"
"    }\n"
"\n"
"    if (ivalence < 0) {\n"
"        if (valence > 2) {\n"
"            v.P = (OsdReadVertex(boundaryEdgeNeighbors[0]) +\n"
"                   OsdReadVertex(boundaryEdgeNeighbors[1]) +\n"
"                   4.0f * pos)/6.0f;\n"
"        } else {\n"
"            v.P = pos;\n"
"        }\n"
"\n"
"        v.e0 = (OsdReadVertex(boundaryEdgeNeighbors[0]) -\n"
"                OsdReadVertex(boundaryEdgeNeighbors[1]))/6.0;\n"
"\n"
"        float k = float(float(valence) - 1.0f);    //k is the number of faces\n"
"        float c = cos(M_PI/k);\n"
"        float s = sin(M_PI/k);\n"
"        float gamma = -(4.0f*s)/(3.0f*k+c);\n"
"        float alpha_0k = -((1.0f+2.0f*c)*sqrt(1.0f+c))/((3.0f*k+c)*sqrt(1.0f-c));\n"
"        float beta_0 = s/(3.0f*k + c);\n"
"\n"
"        int idx_diagonal = OsdReadVertexIndex(vID, 2*zerothNeighbor + 1);\n"
"        vec3 diagonal = OsdReadVertex(idx_diagonal);\n"
"\n"
"        v.e1 = gamma * pos +\n"
"            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[0]) +\n"
"            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[1]) +\n"
"            beta_0 * diagonal;\n"
"\n"
"        for (int x=1; x<valence - 1; ++x) {\n"
"            int curri = ((x + zerothNeighbor)%valence);\n"
"            float alpha = (4.0f*sin((M_PI * float(x))/k))/(3.0f*k+c);\n"
"            float beta = (sin((M_PI * float(x))/k) + sin((M_PI * float(x+1))/k))/(3.0f*k+c);\n"
"\n"
"            int idx_neighbor = OsdReadVertexIndex(vID, 2*curri);\n"
"            vec3 neighbor = OsdReadVertex(idx_neighbor);\n"
"\n"
"            idx_diagonal = OsdReadVertexIndex(vID, 2*curri + 1);\n"
"            diagonal = OsdReadVertex(idx_diagonal);\n"
"\n"
"            v.e1 += alpha * neighbor + beta * diagonal;\n"
"        }\n"
"\n"
"        v.e1 /= 3.0f;\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"void\n"
"OsdComputePerPatchVertexGregory(ivec3 patchParam, int ID, int primitiveID,\n"
"                                in OsdPerVertexGregory v[4],\n"
"                                out OsdPerPatchVertexGregory result)\n"
"{\n"
"    result.patchParam = patchParam;\n"
"    result.P = v[ID].P;\n"
"\n"
"    int i = ID;\n"
"    int ip = (i+1)%4;\n"
"    int im = (i+3)%4;\n"
"    int valence = abs(v[i].valence);\n"
"    int n = valence;\n"
"\n"
"    int start = OsdReadQuadOffset(primitiveID, i) & 0xff;\n"
"    int prev = (OsdReadQuadOffset(primitiveID, i) >> 8) & 0xff;\n"
"\n"
"    int start_m = OsdReadQuadOffset(primitiveID, im) & 0xff;\n"
"    int prev_p = (OsdReadQuadOffset(primitiveID, ip) >> 8) & 0xff;\n"
"\n"
"    int np = abs(v[ip].valence);\n"
"    int nm = abs(v[im].valence);\n"
"\n"
"    // Control Vertices based on :\n"
"    // \"Approximating Subdivision Surfaces with Gregory Patches\n"
"    //  for Hardware Tessellation\"\n"
"    // Loop, Schaefer, Ni, Castano (ACM ToG Siggraph Asia 2009)\n"
"    //\n"
"    //  P3         e3-      e2+         P2\n"
"    //     O--------O--------O--------O\n"
"    //     |        |        |        |\n"
"    //     |        |        |        |\n"
"    //     |        | f3-    | f2+    |\n"
"    //     |        O        O        |\n"
"    // e3+ O------O            O------O e2-\n"
"    //     |     f3+          f2-     |\n"
"    //     |                          |\n"
"    //     |                          |\n"
"    //     |      f0-         f1+     |\n"
"    // e0- O------O            O------O e1+\n"
"    //     |        O        O        |\n"
"    //     |        | f0+    | f1-    |\n"
"    //     |        |        |        |\n"
"    //     |        |        |        |\n"
"    //     O--------O--------O--------O\n"
"    //  P0         e0+      e1-         P1\n"
"    //\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    vec3 Em_ip;\n"
"    if (v[ip].valence < -2) {\n"
"        int j = (np + prev_p - v[ip].zerothNeighbor) % np;\n"
"        Em_ip = v[ip].P + cos((M_PI*j)/float(np-1))*v[ip].e0 + sin((M_PI*j)/float(np-1))*v[ip].e1;\n"
"    } else {\n"
"        Em_ip = v[ip].P + v[ip].e0*cosfn(np, prev_p ) + v[ip].e1*sinfn(np, prev_p);\n"
"    }\n"
"\n"
"    vec3 Ep_im;\n"
"    if (v[im].valence < -2) {\n"
"        int j = (nm + start_m - v[im].zerothNeighbor) % nm;\n"
"        Ep_im = v[im].P + cos((M_PI*j)/float(nm-1))*v[im].e0 + sin((M_PI*j)/float(nm-1))*v[im].e1;\n"
"    } else {\n"
"        Ep_im = v[im].P + v[im].e0*cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);\n"
"    }\n"
"\n"
"    if (v[i].valence < 0) {\n"
"        n = (n-1)*2;\n"
"    }\n"
"    if (v[im].valence < 0) {\n"
"        nm = (nm-1)*2;\n"
"    }\n"
"    if (v[ip].valence < 0) {\n"
"        np = (np-1)*2;\n"
"    }\n"
"\n"
"    if (v[i].valence > 2) {\n"
"        result.Ep = v[i].P + v[i].e0*cosfn(n, start) + v[i].e1*sinfn(n, start);\n"
"        result.Em = v[i].P + v[i].e0*cosfn(n, prev ) + v[i].e1*sinfn(n, prev);\n"
"\n"
"        float s1=3-2*cosfn(n,1)-cosfn(np,1);\n"
"        float s2=2*cosfn(n,1);\n"
"\n"
"        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"        s1 = 3.0f-2.0f*cos(2.0f*M_PI/float(n))-cos(2.0f*M_PI/float(nm));\n"
"        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"\n"
"    } else if (v[i].valence < -2) {\n"
"        int j = (valence + start - v[i].zerothNeighbor) % valence;\n"
"\n"
"        result.Ep = v[i].P + cos((M_PI*j)/float(valence-1))*v[i].e0 + sin((M_PI*j)/float(valence-1))*v[i].e1;\n"
"        j = (valence + prev - v[i].zerothNeighbor) % valence;\n"
"        result.Em = v[i].P + cos((M_PI*j)/float(valence-1))*v[i].e0 + sin((M_PI*j)/float(valence-1))*v[i].e1;\n"
"\n"
"        vec3 Rp = ((-2.0f * v[i].org - 1.0f * v[im].org) + (2.0f * v[ip].org + 1.0f * v[(i+2)%4].org))/3.0f;\n"
"        vec3 Rm = ((-2.0f * v[i].org - 1.0f * v[ip].org) + (2.0f * v[im].org + 1.0f * v[(i+2)%4].org))/3.0f;\n"
"\n"
"        float s1 = 3-2*cosfn(n,1)-cosfn(np,1);\n"
"        float s2 = 2*cosfn(n,1);\n"
"\n"
"        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"        s1 = 3.0f-2.0f*cos(2.0f*M_PI/float(n))-cos(2.0f*M_PI/float(nm));\n"
"        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"\n"
"        if (v[im].valence < 0) {\n"
"            s1 = 3-2*cosfn(n,1)-cosfn(np,1);\n"
"            result.Fp = result.Fm = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"        } else if (v[ip].valence < 0) {\n"
"            s1 = 3.0f-2.0f*cos(2.0f*M_PI/n)-cos(2.0f*M_PI/nm);\n"
"            result.Fm = result.Fp = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"        }\n"
"\n"
"    } else if (v[i].valence == -2) {\n"
"        result.Ep = (2.0f * v[i].org + v[ip].org)/3.0f;\n"
"        result.Em = (2.0f * v[i].org + v[im].org)/3.0f;\n"
"        result.Fp = result.Fm = (4.0f * v[i].org + v[(i+2)%n].org + 2.0f * v[ip].org + 2.0f * v[im].org)/9.0f;\n"
"    }\n"
"\n"
"#else // not OSD_PATCH_GREGORY_BOUNDARY\n"
"\n"
"    result.Ep = v[i].P + v[i].e0 * cosfn(n, start) + v[i].e1*sinfn(n, start);\n"
"    result.Em = v[i].P + v[i].e0 * cosfn(n, prev ) + v[i].e1*sinfn(n, prev);\n"
"\n"
"    vec3 Em_ip = v[ip].P + v[ip].e0 * cosfn(np, prev_p ) + v[ip].e1*sinfn(np, prev_p);\n"
"    vec3 Ep_im = v[im].P + v[im].e0 * cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);\n"
"\n"
"    float s1 = 3-2*cosfn(n,1)-cosfn(np,1);\n"
"    float s2 = 2*cosfn(n,1);\n"
"\n"
"    result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"    s1 = 3.0f-2.0f*cos(2.0f*M_PI/float(n))-cos(2.0f*M_PI/float(nm));\n"
"    result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"#endif\n"
"}\n"
"\n"
"#endif  // OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY\n"
"\n"
