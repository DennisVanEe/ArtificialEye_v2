"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.VertexGregory\n"
"//----------------------------------------------------------\n"
"\n"
"void vs_main_patches( in InputVertex input,\n"
"                      uint vID : SV_VertexID,\n"
"                      out OsdPerVertexGregory output )\n"
"{\n"
"    OsdComputePerVertexGregory(vID, input.position, output);\n"
"    OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(input.position);\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.HullGregory\n"
"//----------------------------------------------------------\n"
"\n"
"[domain(\"quad\")]\n"
"[partitioning(OSD_PARTITIONING)]\n"
"[outputtopology(\"triangle_cw\")]\n"
"[outputcontrolpoints(4)]\n"
"[patchconstantfunc(\"HSConstFunc\")]\n"
"OsdPerPatchVertexGregory hs_main_patches(\n"
"    in InputPatch<OsdPerVertexGregory, 4> patch,\n"
"    uint primitiveID : SV_PrimitiveID,\n"
"    in uint ID : SV_OutputControlPointID )\n"
"{\n"
"    OsdPerPatchVertexGregory output;\n"
"\n"
"    OsdPerVertexGregory cv[4];\n"
"    for (int i=0; i<4; ++i) {\n"
"        cv[i] = patch[i];\n"
"    }\n"
"\n"
"    int3 patchParam = OsdGetPatchParam(OsdGetPatchIndex(primitiveID));\n"
"    OsdComputePerPatchVertexGregory(patchParam, ID, primitiveID, cv, output);\n"
"\n"
"    return output;\n"
"}\n"
"\n"
"HS_CONSTANT_FUNC_OUT HSConstFunc(\n"
"    InputPatch<OsdPerVertexGregory, 4> patch,\n"
"    uint primitiveID : SV_PrimitiveID)\n"
"{\n"
"    HS_CONSTANT_FUNC_OUT output;\n"
"\n"
"    int3 patchParam = OsdGetPatchParam(OsdGetPatchIndex(primitiveID));\n"
"\n"
"    float4 tessLevelOuter = float4(0,0,0,0);\n"
"    float2 tessLevelInner = float2(0,0);\n"
"\n"
"    OSD_PATCH_CULL(4);\n"
"\n"
"    OsdGetTessLevels(patch[0].P, patch[3].P, patch[2].P, patch[1].P,\n"
"                     patchParam, tessLevelOuter, tessLevelInner);\n"
"\n"
"    output.tessLevelOuter[0] = tessLevelOuter[0];\n"
"    output.tessLevelOuter[1] = tessLevelOuter[1];\n"
"    output.tessLevelOuter[2] = tessLevelOuter[2];\n"
"    output.tessLevelOuter[3] = tessLevelOuter[3];\n"
"\n"
"    output.tessLevelInner[0] = tessLevelInner[0];\n"
"    output.tessLevelInner[1] = tessLevelInner[1];\n"
"\n"
"    output.tessOuterLo = float4(0,0,0,0);\n"
"    output.tessOuterHi = float4(0,0,0,0);\n"
"\n"
"    return output;\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.DomainGregory\n"
"//----------------------------------------------------------\n"
"\n"
"[domain(\"quad\")]\n"
"void ds_main_patches(\n"
"    in HS_CONSTANT_FUNC_OUT input,\n"
"    in OutputPatch<OsdPerPatchVertexGregory, 4> patch,\n"
"    in float2 UV : SV_DomainLocation,\n"
"    out OutputVertex output )\n"
"{\n"
"    float3 P = float3(0,0,0), dPu = float3(0,0,0), dPv = float3(0,0,0);\n"
"    float3 N = float3(0,0,0), dNu = float3(0,0,0), dNv = float3(0,0,0);\n"
"\n"
"    float3 cv[20];\n"
"    cv[0] = patch[0].P;\n"
"    cv[1] = patch[0].Ep;\n"
"    cv[2] = patch[0].Em;\n"
"    cv[3] = patch[0].Fp;\n"
"    cv[4] = patch[0].Fm;\n"
"\n"
"    cv[5] = patch[1].P;\n"
"    cv[6] = patch[1].Ep;\n"
"    cv[7] = patch[1].Em;\n"
"    cv[8] = patch[1].Fp;\n"
"    cv[9] = patch[1].Fm;\n"
"\n"
"    cv[10] = patch[2].P;\n"
"    cv[11] = patch[2].Ep;\n"
"    cv[12] = patch[2].Em;\n"
"    cv[13] = patch[2].Fp;\n"
"    cv[14] = patch[2].Fm;\n"
"\n"
"    cv[15] = patch[3].P;\n"
"    cv[16] = patch[3].Ep;\n"
"    cv[17] = patch[3].Em;\n"
"    cv[18] = patch[3].Fp;\n"
"    cv[19] = patch[3].Fm;\n"
"\n"
"    int3 patchParam = patch[0].patchParam;\n"
"    OsdEvalPatchGregory(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);\n"
"\n"
"    // all code below here is client code\n"
"    output.position = mul(OsdModelViewMatrix(), float4(P, 1.0f));\n"
"    output.normal = mul(OsdModelViewMatrix(), float4(N, 0.0f)).xyz;\n"
"    output.tangent = mul(OsdModelViewMatrix(), float4(dPu, 0.0f)).xyz;\n"
"    output.bitangent = mul(OsdModelViewMatrix(), float4(dPv, 0.0f)).xyz;\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    output.Nu = dNu;\n"
"    output.Nv = dNv;\n"
"#endif\n"
"\n"
"    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);\n"
"\n"
"    OSD_DISPLACEMENT_CALLBACK;\n"
"\n"
"    output.positionOut = mul(OsdProjectionMatrix(), output.position);\n"
"    output.edgeDistance = 0;\n"
"}\n"
"\n"
