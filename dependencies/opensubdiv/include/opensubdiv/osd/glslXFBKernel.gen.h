"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"uniform samplerBuffer vertexBuffer;\n"
"uniform int srcOffset = 0;\n"
"out float outVertexBuffer[LENGTH];\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"struct Vertex {\n"
"    float vertexData[LENGTH];\n"
"};\n"
"\n"
"void clear(out Vertex v) {\n"
"    for (int i = 0; i < LENGTH; i++) {\n"
"        v.vertexData[i] = 0;\n"
"    }\n"
"}\n"
"\n"
"void addWithWeight(inout Vertex v, Vertex src, float weight) {\n"
"    for(int j = 0; j < LENGTH; j++) {\n"
"        v.vertexData[j] += weight * src.vertexData[j];\n"
"    }\n"
"}\n"
"\n"
"Vertex readVertex(int index) {\n"
"    Vertex v;\n"
"    int vertexIndex = srcOffset + index * SRC_STRIDE;\n"
"    for(int j = 0; j < LENGTH; j++) {\n"
"        v.vertexData[j] = texelFetch(vertexBuffer, vertexIndex+j).x;\n"
"    }\n"
"    return v;\n"
"}\n"
"\n"
"void writeVertex(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outVertexBuffer[i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_1ST_DERIVATIVES) && "
"    defined(OPENSUBDIV_GLSL_XFB_INTERLEAVED_1ST_DERIVATIVE_BUFFERS)\n"
"out float outDeriv1Buffer[2*LENGTH];\n"
"\n"
"void writeDu(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDeriv1Buffer[i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDv(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDeriv1Buffer[i+LENGTH] = v.vertexData[i];\n"
"    }\n"
"}\n"
"#elif defined(OPENSUBDIV_GLSL_XFB_USE_1ST_DERIVATIVES)\n"
"out float outDuBuffer[LENGTH];\n"
"out float outDvBuffer[LENGTH];\n"
"\n"
"void writeDu(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDuBuffer[i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDv(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDvBuffer[i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"#endif\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_2ND_DERIVATIVES) && "
"    defined(OPENSUBDIV_GLSL_XFB_INTERLEAVED_2ND_DERIVATIVE_BUFFERS)\n"
"out float outDeriv2Buffer[3*LENGTH];\n"
"\n"
"void writeDuu(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDeriv2Buffer[i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDuv(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDeriv2Buffer[i+LENGTH] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDvv(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDeriv2Buffer[i+2*LENGTH] = v.vertexData[i];\n"
"    }\n"
"}\n"
"#elif defined(OPENSUBDIV_GLSL_XFB_USE_2ND_DERIVATIVES)\n"
"out float outDuuBuffer[LENGTH];\n"
"out float outDuvBuffer[LENGTH];\n"
"out float outDvvBuffer[LENGTH];\n"
"\n"
"void writeDuu(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDuuBuffer[i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDuv(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDuvBuffer[i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDvv(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDvvBuffer[i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_KERNEL_EVAL_STENCILS)\n"
"\n"
"uniform usamplerBuffer sizes;\n"
"uniform isamplerBuffer offsets;\n"
"uniform isamplerBuffer indices;\n"
"uniform samplerBuffer  weights;\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_1ST_DERIVATIVES)\n"
"uniform samplerBuffer  duWeights;\n"
"uniform samplerBuffer  dvWeights;\n"
"#endif\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_2ND_DERIVATIVES)\n"
"uniform samplerBuffer  duuWeights;\n"
"uniform samplerBuffer  duvWeights;\n"
"uniform samplerBuffer  dvvWeights;\n"
"#endif\n"
"\n"
"uniform int batchStart = 0;\n"
"uniform int batchEnd = 0;\n"
"\n"
"void main() {\n"
"    int current = gl_VertexID + batchStart;\n"
"\n"
"    if (current>=batchEnd) {\n"
"        return;\n"
"    }\n"
"\n"
"    Vertex dst, du, dv, duu, duv, dvv;\n"
"    clear(dst);\n"
"    clear(du);\n"
"    clear(dv);\n"
"    clear(duu);\n"
"    clear(duv);\n"
"    clear(dvv);\n"
"\n"
"    int offset = texelFetch(offsets, current).x;\n"
"    uint size = texelFetch(sizes, current).x;\n"
"\n"
"    for (int stencil=0; stencil<size; ++stencil) {\n"
"        int index = texelFetch(indices, offset+stencil).x;\n"
"        float weight = texelFetch(weights, offset+stencil).x;\n"
"        addWithWeight(dst, readVertex( index ), weight);\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_1ST_DERIVATIVES)\n"
"        float duWeight = texelFetch(duWeights, offset+stencil).x;\n"
"        float dvWeight = texelFetch(dvWeights, offset+stencil).x;\n"
"        addWithWeight(du,  readVertex(index), duWeight);\n"
"        addWithWeight(dv,  readVertex(index), dvWeight);\n"
"#endif\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_2ND_DERIVATIVES)\n"
"        float duuWeight = texelFetch(duuWeights, offset+stencil).x;\n"
"        float duvWeight = texelFetch(duvWeights, offset+stencil).x;\n"
"        float dvvWeight = texelFetch(dvvWeights, offset+stencil).x;\n"
"        addWithWeight(duu,  readVertex(index), duuWeight);\n"
"        addWithWeight(duv,  readVertex(index), duvWeight);\n"
"        addWithWeight(dvv,  readVertex(index), dvvWeight);\n"
"#endif\n"
"    }\n"
"    writeVertex(dst);\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_1ST_DERIVATIVES)\n"
"    writeDu(du);\n"
"    writeDv(dv);\n"
"#endif\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_2ND_DERIVATIVES)\n"
"    writeDuu(duu);\n"
"    writeDuv(duv);\n"
"    writeDvv(dvv);\n"
"#endif\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_KERNEL_EVAL_PATCHES)\n"
"\n"
"layout (location = 0) in ivec3 patchHandles;\n"
"layout (location = 1) in vec2  patchCoords;\n"
"\n"
"//struct PatchArray {\n"
"//    int patchType;\n"
"//    int numPatches;\n"
"//    int indexBase;        // an offset within the index buffer\n"
"//    int primitiveIdBase;  // an offset within the patch param buffer\n"
"//};\n"
"// # of patcharrays is 1 or 2.\n"
"\n"
"uniform ivec4 patchArray[2];\n"
"uniform isamplerBuffer patchParamBuffer;\n"
"uniform isamplerBuffer patchIndexBuffer;\n"
"\n"
"uint getDepth(uint patchBits) {\n"
"    return (patchBits & 0xfU);\n"
"}\n"
"\n"
"float getParamFraction(uint patchBits) {\n"
"    uint nonQuadRoot = (patchBits >> 4) & 0x1U;\n"
"    uint depth = getDepth(patchBits);\n"
"    if (nonQuadRoot == 1) {\n"
"        return 1.0f / float( 1 << (depth-1) );\n"
"    } else {\n"
"        return 1.0f / float( 1 << depth );\n"
"    }\n"
"}\n"
"\n"
"vec2 normalizePatchCoord(uint patchBits, vec2 uv) {\n"
"    float frac = getParamFraction(patchBits);\n"
"\n"
"    uint iu = (patchBits >> 22) & 0x3ffU;\n"
"    uint iv = (patchBits >> 12) & 0x3ffU;\n"
"\n"
"    // top left corner\n"
"    float pu = float(iu*frac);\n"
"    float pv = float(iv*frac);\n"
"\n"
"    // normalize u,v coordinates\n"
"    return vec2((uv.x - pu) / frac, (uv.y - pv) / frac);\n"
"}\n"
"\n"
"bool isRegular(uint patchBits) {\n"
"    return (((patchBits >> 5) & 0x1u) != 0);\n"
"}\n"
"\n"
"int getNumControlVertices(int patchType) {\n"
"    return (patchType == 3) ? 4 :\n"
"           (patchType == 6) ? 16 :\n"
"           (patchType == 9) ? 20 : 0;\n"
"}\n"
"\n"
"void main() {\n"
"    int current = gl_VertexID;\n"
"\n"
"    ivec3 handle = patchHandles;\n"
"    int patchIndex = handle.y;\n"
"\n"
"    vec2 coord = patchCoords;\n"
"    ivec4 array = patchArray[handle.x];\n"
"\n"
"    uint patchBits = texelFetch(patchParamBuffer, patchIndex).y;\n"
"    int patchType = isRegular(patchBits) ? 6 : array.x;\n"
"\n"
"    // normalize\n"
"    coord = normalizePatchCoord(patchBits, coord);\n"
"    float dScale = float(1 << getDepth(patchBits));\n"
"    int boundary = int((patchBits >> 8) & 0xfU);\n"
"\n"
"    float wP[20], wDs[20], wDt[20], wDss[20], wDst[20], wDtt[20];\n"
"\n"
"    int numControlVertices = 0;\n"
"    if (patchType == 3) {\n"
"        float wP4[4], wDs4[4], wDt4[4], wDss4[4], wDst4[4], wDtt4[4];\n"
"        OsdGetBilinearPatchWeights(coord.s, coord.t, dScale, wP4,\n"
"                                   wDs4, wDt4, wDss4, wDst4, wDtt4);\n"
"        numControlVertices = 4;\n"
"        for (int i=0; i<numControlVertices; ++i) {\n"
"            wP[i] = wP4[i];\n"
"            wDs[i] = wDs4[i];\n"
"            wDt[i] = wDt4[i];\n"
"            wDss[i] = wDss4[i];\n"
"            wDst[i] = wDst4[i];\n"
"            wDtt[i] = wDtt4[i];\n"
"        }\n"
"    } else if (patchType == 6) {\n"
"        float wP16[16], wDs16[16], wDt16[16], wDss16[16], wDst16[16], wDtt16[16];\n"
"        OsdGetBSplinePatchWeights(coord.s, coord.t, dScale, boundary, wP16,\n"
"                                  wDs16, wDt16, wDss16, wDst16, wDtt16);\n"
"        numControlVertices = 16;\n"
"        for (int i=0; i<numControlVertices; ++i) {\n"
"            wP[i] = wP16[i];\n"
"            wDs[i] = wDs16[i];\n"
"            wDt[i] = wDt16[i];\n"
"            wDss[i] = wDss16[i];\n"
"            wDst[i] = wDst16[i];\n"
"            wDtt[i] = wDtt16[i];\n"
"        }\n"
"    } else if (patchType == 9) {\n"
"        OsdGetGregoryPatchWeights(coord.s, coord.t, dScale, wP,\n"
"                                  wDs, wDt, wDss, wDst, wDtt);\n"
"        numControlVertices = 20;\n"
"    }\n"
"\n"
"    Vertex dst, du, dv, duu, duv, dvv;\n"
"    clear(dst);\n"
"    clear(du);\n"
"    clear(dv);\n"
"    clear(duu);\n"
"    clear(duv);\n"
"    clear(dvv);\n"
"\n"
"    int indexStride = getNumControlVertices(array.x);\n"
"    int indexBase = array.z + indexStride * (patchIndex - array.w);\n"
"\n"
"    for (int cv = 0; cv < numControlVertices; ++cv) {\n"
"        int index = texelFetch(patchIndexBuffer, indexBase + cv).x;\n"
"        addWithWeight(dst, readVertex(index), wP[cv]);\n"
"        addWithWeight(du,  readVertex(index), wDs[cv]);\n"
"        addWithWeight(dv,  readVertex(index), wDt[cv]);\n"
"        addWithWeight(duu, readVertex(index), wDss[cv]);\n"
"        addWithWeight(duv, readVertex(index), wDst[cv]);\n"
"        addWithWeight(dvv, readVertex(index), wDtt[cv]);\n"
"    }\n"
"\n"
"    writeVertex(dst);\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_1ST_DERIVATIVES)\n"
"    writeDu(du);\n"
"    writeDv(dv);\n"
"#endif\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_2ND_DERIVATIVES)\n"
"    writeDuu(duu);\n"
"    writeDuv(duv);\n"
"    writeDvv(dvv);\n"
"#endif\n"
"}\n"
"\n"
"#endif\n"
"\n"
"\n"
