"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"\n"
"layout(local_size_x=WORK_GROUP_SIZE, local_size_y=1, local_size_z=1) in;\n"
"layout(std430) buffer;\n"
"\n"
"// source and destination buffers\n"
"\n"
"uniform int srcOffset = 0;\n"
"uniform int dstOffset = 0;\n"
"layout(binding=0) buffer src_buffer      { float    srcVertexBuffer[]; };\n"
"layout(binding=1) buffer dst_buffer      { float    dstVertexBuffer[]; };\n"
"\n"
"// derivative buffers (if needed)\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_1ST_DERIVATIVES)\n"
"uniform ivec3 duDesc;\n"
"uniform ivec3 dvDesc;\n"
"layout(binding=2) buffer du_buffer   { float duBuffer[]; };\n"
"layout(binding=3) buffer dv_buffer   { float dvBuffer[]; };\n"
"#endif\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_2ND_DERIVATIVES)\n"
"uniform ivec3 duuDesc;\n"
"uniform ivec3 duvDesc;\n"
"uniform ivec3 dvvDesc;\n"
"layout(binding=10) buffer duu_buffer   { float duuBuffer[]; };\n"
"layout(binding=11) buffer duv_buffer   { float duvBuffer[]; };\n"
"layout(binding=12) buffer dvv_buffer   { float dvvBuffer[]; };\n"
"#endif\n"
"\n"
"// stencil buffers\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_KERNEL_EVAL_STENCILS)\n"
"\n"
"uniform int batchStart = 0;\n"
"uniform int batchEnd = 0;\n"
"layout(binding=4) buffer stencilSizes    { int      _sizes[];   };\n"
"layout(binding=5) buffer stencilOffsets  { int      _offsets[]; };\n"
"layout(binding=6) buffer stencilIndices  { int      _indices[]; };\n"
"layout(binding=7) buffer stencilWeights  { float    _weights[]; };\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_1ST_DERIVATIVES)\n"
"layout(binding=8) buffer stencilDuWeights { float  _duWeights[]; };\n"
"layout(binding=9) buffer stencilDvWeights { float  _dvWeights[]; };\n"
"#endif\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_2ND_DERIVATIVES)\n"
"layout(binding=13) buffer stencilDuuWeights { float  _duuWeights[]; };\n"
"layout(binding=14) buffer stencilDuvWeights { float  _duvWeights[]; };\n"
"layout(binding=15) buffer stencilDvvWeights { float  _dvvWeights[]; };\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"// patch buffers\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_KERNEL_EVAL_PATCHES)\n"
"\n"
"struct PatchCoord {\n"
"   int arrayIndex;\n"
"   int patchIndex;\n"
"   int vertIndex;\n"
"   float s;\n"
"   float t;\n"
"};\n"
"struct PatchParam {\n"
"    uint field0;\n"
"    uint field1;\n"
"    float sharpness;\n"
"};\n"
"uniform ivec4 patchArray[2];\n"
"layout(binding=4) buffer patchCoord_buffer { PatchCoord patchCoords[]; };\n"
"layout(binding=5) buffer patchIndex_buffer { int patchIndexBuffer[]; };\n"
"layout(binding=6) buffer patchParam_buffer { PatchParam patchParamBuffer[]; };\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"struct Vertex {\n"
"    float vertexData[LENGTH];\n"
"};\n"
"\n"
"void clear(out Vertex v) {\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        v.vertexData[i] = 0;\n"
"    }\n"
"}\n"
"\n"
"Vertex readVertex(int index) {\n"
"    Vertex v;\n"
"    int vertexIndex = srcOffset + index * SRC_STRIDE;\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        v.vertexData[i] = srcVertexBuffer[vertexIndex + i];\n"
"    }\n"
"    return v;\n"
"}\n"
"\n"
"void writeVertex(int index, Vertex v) {\n"
"    int vertexIndex = dstOffset + index * DST_STRIDE;\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        dstVertexBuffer[vertexIndex + i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void addWithWeight(inout Vertex v, const Vertex src, float weight) {\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        v.vertexData[i] += weight * src.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_1ST_DERIVATIVES)\n"
"void writeDu(int index, Vertex du) {\n"
"    int duIndex = duDesc.x + index * duDesc.z;\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        duBuffer[duIndex + i] = du.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDv(int index, Vertex dv) {\n"
"    int dvIndex = dvDesc.x + index * dvDesc.z;\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        dvBuffer[dvIndex + i] = dv.vertexData[i];\n"
"    }\n"
"}\n"
"#endif\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_2ND_DERIVATIVES)\n"
"void writeDuu(int index, Vertex duu) {\n"
"    int duuIndex = duuDesc.x + index * duuDesc.z;\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        duuBuffer[duuIndex + i] = duu.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDuv(int index, Vertex duv) {\n"
"    int duvIndex = duvDesc.x + index * duvDesc.z;\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        duvBuffer[duvIndex + i] = duv.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDvv(int index, Vertex dvv) {\n"
"    int dvvIndex = dvvDesc.x + index * dvvDesc.z;\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        dvvBuffer[dvvIndex + i] = dvv.vertexData[i];\n"
"    }\n"
"}\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_KERNEL_EVAL_STENCILS)\n"
"\n"
"void main() {\n"
"\n"
"    int current = int(gl_GlobalInvocationID.x) + batchStart;\n"
"\n"
"    if (current>=batchEnd) {\n"
"        return;\n"
"    }\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"\n"
"    int offset = _offsets[current],\n"
"        size   = _sizes[current];\n"
"\n"
"    for (int stencil = 0; stencil < size; ++stencil) {\n"
"        int vindex = offset + stencil;\n"
"        addWithWeight(\n"
"            dst, readVertex(_indices[vindex]), _weights[vindex]);\n"
"    }\n"
"\n"
"    writeVertex(current, dst);\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_1ST_DERIVATIVES)\n"
"    Vertex du, dv;\n"
"    clear(du);\n"
"    clear(dv);\n"
"    for (int i=0; i<size; ++i) {\n"
"        // expects the compiler optimizes readVertex out here.\n"
"        Vertex src = readVertex(_indices[offset+i]);\n"
"        addWithWeight(du, src, _duWeights[offset+i]);\n"
"        addWithWeight(dv, src, _dvWeights[offset+i]);\n"
"    }\n"
"\n"
"    if (duDesc.y > 0) { // length\n"
"        writeDu(current, du);\n"
"    }\n"
"    if (dvDesc.y > 0) {\n"
"        writeDv(current, dv);\n"
"    }\n"
"#endif\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_2ND_DERIVATIVES)\n"
"    Vertex duu, duv, dvv;\n"
"    clear(duu);\n"
"    clear(duv);\n"
"    clear(dvv);\n"
"    for (int i=0; i<size; ++i) {\n"
"        // expects the compiler optimizes readVertex out here.\n"
"        Vertex src = readVertex(_indices[offset+i]);\n"
"        addWithWeight(duu, src, _duuWeights[offset+i]);\n"
"        addWithWeight(duv, src, _duvWeights[offset+i]);\n"
"        addWithWeight(dvv, src, _dvvWeights[offset+i]);\n"
"    }\n"
"\n"
"    if (duuDesc.y > 0) { // length\n"
"        writeDuu(current, duu);\n"
"    }\n"
"    if (duvDesc.y > 0) {\n"
"        writeDuv(current, duv);\n"
"    }\n"
"    if (dvvDesc.y > 0) {\n"
"        writeDvv(current, dvv);\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_KERNEL_EVAL_PATCHES)\n"
"\n"
"// PERFORMANCE: stride could be constant, but not as significant as length\n"
"\n"
"//struct PatchArray {\n"
"//    int patchType;\n"
"//    int numPatches;\n"
"//    int indexBase;        // an offset within the index buffer\n"
"//    int primitiveIdBase;  // an offset within the patch param buffer\n"
"//};\n"
"// # of patcharrays is 1 or 2.\n"
"\n"
"uint getDepth(uint patchBits) {\n"
"    return (patchBits & 0xf);\n"
"}\n"
"\n"
"float getParamFraction(uint patchBits) {\n"
"    uint nonQuadRoot = (patchBits >> 4) & 0x1;\n"
"    uint depth = getDepth(patchBits);\n"
"    if (nonQuadRoot == 1) {\n"
"        return 1.0f / float( 1 << (depth-1) );\n"
"    } else {\n"
"        return 1.0f / float( 1 << depth );\n"
"    }\n"
"}\n"
"\n"
"vec2 normalizePatchCoord(uint patchBits, vec2 uv) {\n"
"    float frac = getParamFraction(patchBits);\n"
"\n"
"    uint iu = (patchBits >> 22) & 0x3ff;\n"
"    uint iv = (patchBits >> 12) & 0x3ff;\n"
"\n"
"    // top left corner\n"
"    float pu = float(iu*frac);\n"
"    float pv = float(iv*frac);\n"
"\n"
"    // normalize u,v coordinates\n"
"    return vec2((uv.x - pu) / frac, (uv.y - pv) / frac);\n"
"}\n"
"\n"
"bool isRegular(uint patchBits) {\n"
"    return (((patchBits >> 5) & 0x1u) != 0);\n"
"}\n"
"\n"
"int getNumControlVertices(int patchType) {\n"
"    return (patchType == 3) ? 4 :\n"
"           (patchType == 6) ? 16 :\n"
"           (patchType == 9) ? 20 : 0;\n"
"}\n"
"\n"
"void main() {\n"
"\n"
"    int current = int(gl_GlobalInvocationID.x);\n"
"\n"
"    PatchCoord coord = patchCoords[current];\n"
"    int patchIndex = coord.patchIndex;\n"
"\n"
"    ivec4 array = patchArray[coord.arrayIndex];\n"
"\n"
"    uint patchBits = patchParamBuffer[patchIndex].field1;\n"
"    int patchType = isRegular(patchBits) ? 6 : array.x;\n"
"\n"
"    vec2 uv = normalizePatchCoord(patchBits, vec2(coord.s, coord.t));\n"
"    float dScale = float(1 << getDepth(patchBits));\n"
"    int boundary = int((patchBits >> 8) & 0xfU);\n"
"\n"
"    float wP[20], wDs[20], wDt[20], wDss[20], wDst[20], wDtt[20];\n"
"\n"
"    int numControlVertices = 0;\n"
"    if (patchType == 3) {\n"
"        float wP4[4], wDs4[4], wDt4[4], wDss4[4], wDst4[4], wDtt4[4];\n"
"        OsdGetBilinearPatchWeights(uv.s, uv.t, dScale, wP4, wDs4, wDt4, wDss4, wDst4, wDtt4);\n"
"        numControlVertices = 4;\n"
"        for (int i=0; i<numControlVertices; ++i) {\n"
"            wP[i] = wP4[i];\n"
"            wDs[i] = wDs4[i];\n"
"            wDt[i] = wDt4[i];\n"
"            wDss[i] = wDss4[i];\n"
"            wDst[i] = wDst4[i];\n"
"            wDtt[i] = wDtt4[i];\n"
"        }\n"
"    } else if (patchType == 6) {\n"
"        float wP16[16], wDs16[16], wDt16[16], wDss16[16], wDst16[16], wDtt16[16];\n"
"        OsdGetBSplinePatchWeights(uv.s, uv.t, dScale, boundary, wP16, wDs16, wDt16, wDss16, wDst16, wDtt16);\n"
"        numControlVertices = 16;\n"
"        for (int i=0; i<numControlVertices; ++i) {\n"
"            wP[i] = wP16[i];\n"
"            wDs[i] = wDs16[i];\n"
"            wDt[i] = wDt16[i];\n"
"            wDss[i] = wDss16[i];\n"
"            wDst[i] = wDst16[i];\n"
"            wDtt[i] = wDtt16[i];\n"
"        }\n"
"    } else if (patchType == 9) {\n"
"        OsdGetGregoryPatchWeights(uv.s, uv.t, dScale, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"        numControlVertices = 20;\n"
"    }\n"
"\n"
"    Vertex dst, du, dv, duu, duv, dvv;\n"
"    clear(dst);\n"
"    clear(du);\n"
"    clear(dv);\n"
"    clear(duu);\n"
"    clear(duv);\n"
"    clear(dvv);\n"
"\n"
"    int indexStride = getNumControlVertices(array.x);\n"
"    int indexBase = array.z + indexStride * (patchIndex - array.w);\n"
"\n"
"    for (int cv = 0; cv < numControlVertices; ++cv) {\n"
"        int index = patchIndexBuffer[indexBase + cv];\n"
"        addWithWeight(dst, readVertex(index), wP[cv]);\n"
"        addWithWeight(du, readVertex(index), wDs[cv]);\n"
"        addWithWeight(dv, readVertex(index), wDt[cv]);\n"
"        addWithWeight(duu, readVertex(index), wDss[cv]);\n"
"        addWithWeight(duv, readVertex(index), wDst[cv]);\n"
"        addWithWeight(dvv, readVertex(index), wDtt[cv]);\n"
"    }\n"
"    writeVertex(current, dst);\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_1ST_DERIVATIVES)\n"
"    if (duDesc.y > 0) { // length\n"
"        writeDu(current, du);\n"
"    }\n"
"    if (dvDesc.y > 0) {\n"
"        writeDv(current, dv);\n"
"    }\n"
"#endif\n"
"#if defined(OPENSUBDIV_GLSL_COMPUTE_USE_2ND_DERIVATIVES)\n"
"    if (duuDesc.y > 0) { // length\n"
"        writeDuu(current, duu);\n"
"    }\n"
"    if (duvDesc.y > 0) { // length\n"
"        writeDuv(current, duv);\n"
"    }\n"
"    if (dvvDesc.y > 0) {\n"
"        writeDvv(current, dvv);\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"#endif\n"
"\n"
