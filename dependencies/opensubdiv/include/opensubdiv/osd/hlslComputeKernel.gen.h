"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"cbuffer KernelUniformArgs : register( b0 ) {\n"
"    int batchStart;\n"
"    int batchEnd;\n"
"    int srcOffset;\n"
"    int dstOffset;\n"
"};\n"
"\n"
"RWBuffer<float> vertexBuffer  : register( u0 );\n"
"RWBuffer<float> dstVertexBuffer  : register( u1 );\n"
"Buffer<int>    sizes   : register( t1 );\n"
"Buffer<int>    offsets : register( t2 );\n"
"Buffer<int>    indices : register( t3 );\n"
"Buffer<float>  weights : register( t4 );\n"
"\n"
"//----------------------------------------------------------------------------\n"
"\n"
"struct Vertex {\n"
"    float vertexData[LENGTH];\n"
"};\n"
"\n"
"void clear(out Vertex v) {\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        v.vertexData[i] = 0;\n"
"    }\n"
"}\n"
"\n"
"Vertex readVertex(int index) {\n"
"    Vertex v;\n"
"    int vertexIndex = srcOffset + index * SRC_STRIDE;\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        v.vertexData[i] = vertexBuffer[vertexIndex + i];\n"
"    }\n"
"    return v;\n"
"}\n"
"\n"
"void writeVertex(int index, Vertex v) {\n"
"    int vertexIndex = dstOffset + index * DST_STRIDE;\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        vertexBuffer[vertexIndex + i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeVertexSeparate(int index, Vertex v) {\n"
"    int vertexIndex = dstOffset + index * DST_STRIDE;\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        dstVertexBuffer[vertexIndex + i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void addWithWeight(inout Vertex v, const Vertex src, float weight) {\n"
"    for (int i = 0; i < LENGTH; ++i) {\n"
"        v.vertexData[i] += weight * src.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"// ---------------------------------------------------------------------------\n"
"\n"
"interface IComputeKernel {\n"
"    void runKernel( uint3 ID );\n"
"};\n"
"IComputeKernel kernel;\n"
"\n"
"class SingleBufferCompute : IComputeKernel {\n"
"\n"
"    int placeholder;\n"
"    void runKernel(uint3 ID) {\n"
"        int current = int(ID.x) + batchStart;\n"
"\n"
"        if (current>=batchEnd) {\n"
"            return;\n"
"        }\n"
"\n"
"        Vertex dst;\n"
"        clear(dst);\n"
"\n"
"        int offset = offsets[current],\n"
"            size = sizes[current];\n"
"\n"
"        for (int i=0; i<size; ++i) {\n"
"            addWithWeight(dst, readVertex( indices[offset+i] ), weights[offset+i]);\n"
"        }\n"
"\n"
"        writeVertex(current, dst);\n"
"    }\n"
"};\n"
"class SeparateBufferCompute : IComputeKernel {\n"
"\n"
"    int placeholder;\n"
"    void runKernel(uint3 ID) {\n"
"        int current = int(ID.x) + batchStart;\n"
"\n"
"        if (current>=batchEnd) {\n"
"            return;\n"
"        }\n"
"\n"
"        Vertex dst;\n"
"        clear(dst);\n"
"\n"
"        int offset = offsets[current],\n"
"            size = sizes[current];\n"
"\n"
"        for (int i=0; i<size; ++i) {\n"
"            addWithWeight(dst, readVertex( indices[offset+i] ), weights[offset+i]);\n"
"        }\n"
"\n"
"        writeVertexSeparate(current, dst);\n"
"    }\n"
"};\n"
"\n"
"SingleBufferCompute singleBufferCompute;\n"
"SeparateBufferCompute separateBufferCompute;\n"
"\n"
"// Add place-holder stencil kernel or D3D11ShaderReflection::GetInterfaceSlots()\n"
"// returns 0\n"
"class PlaceHolder : IComputeKernel {\n"
"    int placeholder;\n"
"    void runKernel( uint3 ID ) {\n"
"    }\n"
"};\n"
"\n"
"[numthreads(WORK_GROUP_SIZE, 1, 1)]\n"
"void cs_main( uint3 ID : SV_DispatchThreadID )\n"
"{\n"
"    // call kernel\n"
"    kernel.runKernel(ID);\n"
"}\n"
"\n"
"\n"
