"//\n"
"//   Copyright 2016 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"#ifndef OPENSUBDIV3_OSD_PATCH_BASIS_COMMON_H\n"
"#define OPENSUBDIV3_OSD_PATCH_BASIS_COMMON_H\n"
"\n"
"#if defined(OSD_PATCH_BASIS_GLSL)\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS\n"
"    #define OSD_DATA_STORAGE_CLASS\n"
"    #define OSD_OPTIONAL(a) true\n"
"    #define OSD_OPTIONAL_INIT(a,b) b\n"
"    #define OSD_OUT out\n"
"    #define OSD_INOUT inout\n"
"    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            elementType[](a0,a1,a2,a3,a4,a5,a6,a7)\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            elementType[](a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)\n"
"\n"
"#elif defined(OSD_PATCH_BASIS_HLSL)\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS\n"
"    #define OSD_DATA_STORAGE_CLASS\n"
"    #define OSD_OPTIONAL(a) true\n"
"    #define OSD_OPTIONAL_INIT(a,b) b\n"
"    #define OSD_OUT out\n"
"    #define OSD_INOUT inout\n"
"    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            {a0,a1,a2,a3,a4,a5,a6,a7}\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}\n"
"\n"
"#elif defined(OSD_PATCH_BASIS_CUDA)\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS __device__\n"
"    #define OSD_DATA_STORAGE_CLASS\n"
"    #define OSD_OPTIONAL(a) true\n"
"    #define OSD_OPTIONAL_INIT(a,b) b\n"
"    #define OSD_OUT\n"
"    #define OSD_INOUT\n"
"    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            {a0,a1,a2,a3,a4,a5,a6,a7}\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}\n"
"\n"
"#elif defined(OSD_PATCH_BASIS_OPENCL)\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS static\n"
"    #define OSD_DATA_STORAGE_CLASS\n"
"    #define OSD_OPTIONAL(a) true\n"
"    #define OSD_OPTIONAL_INIT(a,b) b\n"
"    #define OSD_OUT\n"
"    #define OSD_INOUT\n"
"    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            {a0,a1,a2,a3,a4,a5,a6,a7}\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}\n"
"\n"
"#elif defined(OSD_PATCH_BASIS_METAL)\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS\n"
"    #define OSD_DATA_STORAGE_CLASS\n"
"    #define OSD_OPTIONAL(a) true\n"
"    #define OSD_OPTIONAL_INIT(a,b) b\n"
"    #define OSD_OUT\n"
"    #define OSD_INOUT\n"
"    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) thread elementType* identifier\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            {a0,a1,a2,a3,a4,a5,a6,a7}\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}\n"
"\n"
"#else\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS static inline\n"
"    #define OSD_DATA_STORAGE_CLASS static\n"
"    #define OSD_OPTIONAL(a) (a)\n"
"    #define OSD_OPTIONAL_INIT(a,b) (a ? b : 0)\n"
"    #define OSD_OUT\n"
"    #define OSD_INOUT\n"
"    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            {a0,a1,a2,a3,a4,a5,a6,a7}\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}\n"
"\n"
"#endif\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBezierWeights(\n"
"    float t, OSD_TYPE_ARRAY(OSD_OUT float, wP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP2, 4)) {\n"
"\n"
"    // The four uniform cubic Bezier basis functions (in terms of t and its\n"
"    // complement tC) evaluated at t:\n"
"    float t2 = t*t;\n"
"    float tC = 1.0f - t;\n"
"    float tC2 = tC * tC;\n"
"\n"
"    wP[0] = tC2 * tC;\n"
"    wP[1] = tC2 * t * 3.0f;\n"
"    wP[2] = t2 * tC * 3.0f;\n"
"    wP[3] = t2 * t;\n"
"\n"
"    // Derivatives of the above four basis functions at t:\n"
"    if (OSD_OPTIONAL(wDP)) {\n"
"       wDP[0] = -3.0f * tC2;\n"
"       wDP[1] =  9.0f * t2 - 12.0f * t + 3.0f;\n"
"       wDP[2] = -9.0f * t2 +  6.0f * t;\n"
"       wDP[3] =  3.0f * t2;\n"
"    }\n"
"\n"
"    // Second derivatives of the basis functions at t:\n"
"    if (OSD_OPTIONAL(wDP2)) {\n"
"        wDP2[0] =   6.0f * tC;\n"
"        wDP2[1] =  18.0f * t - 12.0f;\n"
"        wDP2[2] = -18.0f * t +  6.0f;\n"
"        wDP2[3] =   6.0f * t;\n"
"    }\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBSplineWeights(\n"
"    float t, OSD_TYPE_ARRAY(OSD_OUT float, wP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP2, 4)) {\n"
"\n"
"    // The four uniform cubic B-Spline basis functions evaluated at t:\n"
"    const float one6th = 1.0f / 6.0f;\n"
"\n"
"    float t2 = t * t;\n"
"    float t3 = t * t2;\n"
"\n"
"    wP[0] = one6th * (1.0f - 3.0f*(t -      t2) -      t3);\n"
"    wP[1] = one6th * (4.0f           - 6.0f*t2  + 3.0f*t3);\n"
"    wP[2] = one6th * (1.0f + 3.0f*(t +      t2  -      t3));\n"
"    wP[3] = one6th * (                                 t3);\n"
"\n"
"    // Derivatives of the above four basis functions at t:\n"
"    if (OSD_OPTIONAL(wDP)) {\n"
"        wDP[0] = -0.5f*t2 +      t - 0.5f;\n"
"        wDP[1] =  1.5f*t2 - 2.0f*t;\n"
"        wDP[2] = -1.5f*t2 +      t + 0.5f;\n"
"        wDP[3] =  0.5f*t2;\n"
"    }\n"
"\n"
"    // Second derivatives of the basis functions at t:\n"
"    if (OSD_OPTIONAL(wDP2)) {\n"
"        wDP2[0] = -       t + 1.0f;\n"
"        wDP2[1] =  3.0f * t - 2.0f;\n"
"        wDP2[2] = -3.0f * t + 1.0f;\n"
"        wDP2[3] =         t;\n"
"    }\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBoxSplineWeights(float v, float w, OSD_TYPE_ARRAY(OSD_OUT float, wP, 12)) {\n"
"\n"
"    float u = 1.0f - v - w;\n"
"\n"
"    //\n"
"    //  The 12 basis functions of the quartic box spline (unscaled by their common\n"
"    //  factor of 1/12 until later, and formatted to make it easy to spot any\n"
"    //  typing errors):\n"
"    //\n"
"    //      15 terms for the 3 points above the triangle corners\n"
"    //       9 terms for the 3 points on faces opposite the triangle edges\n"
"    //       2 terms for the 6 points on faces opposite the triangle corners\n"
"    //\n"
"    //  Powers of each variable for notational convenience:\n"
"    float u2 = u*u;\n"
"    float u3 = u*u2;\n"
"    float u4 = u*u3;\n"
"    float v2 = v*v;\n"
"    float v3 = v*v2;\n"
"    float v4 = v*v3;\n"
"    float w2 = w*w;\n"
"    float w3 = w*w2;\n"
"    float w4 = w*w3;\n"
"\n"
"    //  And now the basis functions:\n"
"    wP[ 0] = u4 + 2.0f*u3*v;\n"
"    wP[ 1] = u4 + 2.0f*u3*w;\n"
"    wP[ 8] = w4 + 2.0f*w3*u;\n"
"    wP[11] = w4 + 2.0f*w3*v;\n"
"    wP[ 9] = v4 + 2.0f*v3*w;\n"
"    wP[ 5] = v4 + 2.0f*v3*u;\n"
"\n"
"    wP[ 2] = u4 + 2.0f*u3*w + 6.0f*u3*v + 6.0f*u2*v*w + 12.0f*u2*v2 +\n"
"                v4 + 2.0f*v3*w + 6.0f*v3*u + 6.0f*v2*u*w;\n"
"    wP[ 4] = w4 + 2.0f*w3*v + 6.0f*w3*u + 6.0f*w2*u*v + 12.0f*w2*u2 +\n"
"                u4 + 2.0f*u3*v + 6.0f*u3*w + 6.0f*u2*v*w;\n"
"    wP[10] = v4 + 2.0f*v3*u + 6.0f*v3*w + 6.0f*v2*w*u + 12.0f*v2*w2 +\n"
"                w4 + 2.0f*w3*u + 6.0f*w3*v + 6.0f*w3*u*v;\n"
"\n"
"    wP[ 3] = v4 + 6*v3*w + 8*v3*u + 36*v2*w*u + 24*v2*u2 + 24*v*u3 +\n"
"                w4 + 6*w3*v + 8*w3*u + 36*w2*v*u + 24*w2*u2 + 24*w*u3 + 6*u4 + 60*u2*v*w + 12*v2*w2;\n"
"    wP[ 6] = w4 + 6*w3*u + 8*w3*v + 36*w2*u*v + 24*w2*v2 + 24*w*v3 +\n"
"                u4 + 6*u3*w + 8*u3*v + 36*u2*v*w + 24*u2*v2 + 24*u*v3 + 6*v4 + 60*v2*w*u + 12*w2*u2;\n"
"    wP[ 7] = u4 + 6*u3*v + 8*u3*w + 36*u2*v*w + 24*u2*w2 + 24*u*w3 +\n"
"                v4 + 6*v3*u + 8*v3*w + 36*v2*u*w + 24*v2*w2 + 24*v*w3 + 6*w4 + 60*w2*u*v + 12*u2*v2;\n"
"\n"
"    for (int i = 0; i < 12; ++i) {\n"
"        wP[i] *= 1.0f / 12.0f;\n"
"    }\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBilinearPatchWeights(\n"
"        float s, float t, float dScale,\n"
"        OSD_TYPE_ARRAY(OSD_OUT float, wP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 4),\n"
"        OSD_TYPE_ARRAY(OSD_OUT float, wDss, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 4)) {\n"
"\n"
"    float sC = 1.0f - s,\n"
"          tC = 1.0f - t;\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        wP[0] = sC * tC;\n"
"        wP[1] =  s * tC;\n"
"        wP[2] =  s * t;\n"
"        wP[3] = sC * t;\n"
"    }\n"
"\n"
"    if (OSD_OPTIONAL(derivS && derivT)) {\n"
"\n"
"        wDs[0] = -tC * dScale;\n"
"        wDs[1] =  tC * dScale;\n"
"        wDs[2] =   t * dScale;\n"
"        wDs[3] =  -t * dScale;\n"
"\n"
"        wDt[0] = -sC * dScale;\n"
"        wDt[1] =  -s * dScale;\n"
"        wDt[2] =   s * dScale;\n"
"        wDt[3] =  sC * dScale;\n"
"\n"
"        if (OSD_OPTIONAL(derivSS && derivST && derivTT)) {\n"
"            float d2Scale = dScale * dScale;\n"
"\n"
"            for(int i=0;i<4;i++) {\n"
"                wDss[i] = 0;\n"
"                wDtt[i] = 0;\n"
"            }\n"
"\n"
"            wDst[0] =  d2Scale;\n"
"            wDst[1] = -d2Scale;\n"
"            wDst[2] = -d2Scale;\n"
"            wDst[3] =  d2Scale;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void OsdAdjustBoundaryWeights(\n"
"        int boundary,\n"
"        OSD_TYPE_ARRAY(OSD_INOUT float, sWeights, 4), OSD_TYPE_ARRAY(OSD_INOUT float, tWeights, 4)) {\n"
"\n"
"    if ((boundary & 1) != 0) {\n"
"        tWeights[2] -= tWeights[0];\n"
"        tWeights[1] += 2*tWeights[0];\n"
"        tWeights[0] = 0;\n"
"    }\n"
"    if ((boundary & 2) != 0) {\n"
"        sWeights[1] -= sWeights[3];\n"
"        sWeights[2] += 2*sWeights[3];\n"
"        sWeights[3] = 0;\n"
"    }\n"
"    if ((boundary & 4) != 0) {\n"
"        tWeights[1] -= tWeights[3];\n"
"        tWeights[2] += 2*tWeights[3];\n"
"        tWeights[3] = 0;\n"
"    }\n"
"    if ((boundary & 8) != 0) {\n"
"        sWeights[2] -= sWeights[0];\n"
"        sWeights[1] += 2*sWeights[0];\n"
"        sWeights[0] = 0;\n"
"    }\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void OsdComputeTensorProductPatchWeights(float dScale, int boundary,\n"
"    OSD_TYPE_ARRAY(float, sWeights, 4), OSD_TYPE_ARRAY(float, tWeights, 4),\n"
"    OSD_TYPE_ARRAY(float, dsWeights, 4), OSD_TYPE_ARRAY(float, dtWeights, 4),\n"
"    OSD_TYPE_ARRAY(float, dssWeights, 4), OSD_TYPE_ARRAY(float, dttWeights, 4),\n"
"    OSD_TYPE_ARRAY(OSD_OUT float, wP, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 16),\n"
"    OSD_TYPE_ARRAY(OSD_OUT float, wDss, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 16)) {\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        // Compute the tensor product weight of the (s,t) basis function\n"
"        // corresponding to each control vertex:\n"
"\n"
"        OsdAdjustBoundaryWeights(boundary, sWeights, tWeights);\n"
"\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wP[4*i+j] = sWeights[j] * tWeights[i];\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    if (OSD_OPTIONAL(derivS && derivT)) {\n"
"        // Compute the tensor product weight of the differentiated (s,t) basis\n"
"        // function corresponding to each control vertex (scaled accordingly):\n"
"\n"
"        OsdAdjustBoundaryWeights(boundary, dsWeights, dtWeights);\n"
"\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wDs[4*i+j] = dsWeights[j] * tWeights[i] * dScale;\n"
"                wDt[4*i+j] = sWeights[j] * dtWeights[i] * dScale;\n"
"            }\n"
"        }\n"
"\n"
"        if (OSD_OPTIONAL(derivSS && derivST && derivTT)) {\n"
"            // Compute the tensor product weight of appropriate differentiated\n"
"            // (s,t) basis functions for each control vertex (scaled accordingly):\n"
"            float d2Scale = dScale * dScale;\n"
"\n"
"            OsdAdjustBoundaryWeights(boundary, dssWeights, dttWeights);\n"
"\n"
"            for (int i = 0; i < 4; ++i) {\n"
"                for (int j = 0; j < 4; ++j) {\n"
"                    wDss[4*i+j] = dssWeights[j] * tWeights[i] * d2Scale;\n"
"                    wDst[4*i+j] = dsWeights[j] * dtWeights[i] * d2Scale;\n"
"                    wDtt[4*i+j] = sWeights[j] * dttWeights[i] * d2Scale;\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void OsdGetBezierPatchWeights(\n"
"    float s, float t, float dScale,\n"
"    OSD_TYPE_ARRAY(OSD_OUT float, wP, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDS, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDT, 16),\n"
"    OSD_TYPE_ARRAY(OSD_OUT float, wDSS, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDST, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDTT, 16)) {\n"
"\n"
"    float sWeights[4], tWeights[4], dsWeights[4], dtWeights[4], dssWeights[4], dttWeights[4];\n"
"\n"
"    OsdGetBezierWeights(s, OSD_OPTIONAL_INIT(wP, sWeights), OSD_OPTIONAL_INIT(wDS, dsWeights), OSD_OPTIONAL_INIT(wDSS, dssWeights));\n"
"    OsdGetBezierWeights(t, OSD_OPTIONAL_INIT(wP, tWeights), OSD_OPTIONAL_INIT(wDT, dtWeights), OSD_OPTIONAL_INIT(wDTT, dttWeights));\n"
"\n"
"    OsdComputeTensorProductPatchWeights(dScale, /*boundary=*/0, sWeights, tWeights, dsWeights, dtWeights, dssWeights, dttWeights, wP, wDS, wDT, wDSS, wDST, wDTT);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void OsdGetBSplinePatchWeights(\n"
"    float s, float t, float dScale, int boundary,\n"
"    OSD_TYPE_ARRAY(OSD_OUT float, wP, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 16),\n"
"    OSD_TYPE_ARRAY(OSD_OUT float, wDss, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 16)) {\n"
"\n"
"    float sWeights[4], tWeights[4], dsWeights[4], dtWeights[4], dssWeights[4], dttWeights[4];\n"
"\n"
"    OsdGetBSplineWeights(s, sWeights, OSD_OPTIONAL_INIT(wDS, dsWeights), OSD_OPTIONAL_INIT(wDSS, dssWeights));\n"
"    OsdGetBSplineWeights(t, tWeights, OSD_OPTIONAL_INIT(wDT, dtWeights), OSD_OPTIONAL_INIT(wDTT, dttWeights));\n"
"\n"
"    OsdComputeTensorProductPatchWeights(dScale, boundary, sWeights, tWeights, dsWeights, dtWeights, dssWeights, dttWeights, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void OsdGetGregoryPatchWeights(\n"
"    float s, float t, float dScale,\n"
"    OSD_TYPE_ARRAY(OSD_OUT float, wP, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 20),\n"
"    OSD_TYPE_ARRAY(OSD_OUT float, wDss, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 20)) {\n"
"\n"
"    //\n"
"    //  P3         e3-      e2+         P2\n"
"    //     15------17-------11--------10\n"
"    //     |        |        |        |\n"
"    //     |        |        |        |\n"
"    //     |        | f3-    | f2+    |\n"
"    //     |       19       13        |\n"
"    // e3+ 16-----18           14-----12 e2-\n"
"    //     |     f3+          f2-     |\n"
"    //     |                          |\n"
"    //     |                          |\n"
"    //     |      f0-         f1+     |\n"
"    // e0- 2------4            8------6 e1+\n"
"    //     |        3        9        |\n"
"    //     |        | f0+    | f1-    |\n"
"    //     |        |        |        |\n"
"    //     |        |        |        |\n"
"    //     O--------1--------7--------5\n"
"    //  P0         e0+      e1-         P1\n"
"    //\n"
"\n"
"    //  Indices of boundary and interior points and their corresponding Bezier points\n"
"    //  (this can be reduced with more direct indexing and unrolling of loops):\n"
"    //\n"
"    OSD_DATA_STORAGE_CLASS const int boundaryGregory[12] = OSD_ARRAY_12(int, 0, 1, 7, 5, 2, 6, 16, 12, 15, 17, 11, 10 );\n"
"    OSD_DATA_STORAGE_CLASS const int boundaryBezSCol[12] = OSD_ARRAY_12(int, 0, 1, 2, 3, 0, 3,  0,  3,  0,  1,  2,  3 );\n"
"    OSD_DATA_STORAGE_CLASS const int boundaryBezTRow[12] = OSD_ARRAY_12(int, 0, 0, 0, 0, 1, 1,  2,  2,  3,  3,  3,  3 );\n"
"\n"
"    OSD_DATA_STORAGE_CLASS const int interiorGregory[8] = OSD_ARRAY_8(int, 3, 4,  8, 9,  13, 14,  18, 19 );\n"
"    OSD_DATA_STORAGE_CLASS const int interiorBezSCol[8] = OSD_ARRAY_8(int, 1, 1,  2, 2,   2,  2,   1,  1 );\n"
"    OSD_DATA_STORAGE_CLASS const int interiorBezTRow[8] = OSD_ARRAY_8(int, 1, 1,  1, 1,   2,  2,   2,  2 );\n"
"\n"
"    //\n"
"    //  Bezier basis functions are denoted with B while the rational multipliers for the\n"
"    //  interior points will be denoted G -- so we have B(s), B(t) and G(s,t):\n"
"    //\n"
"    //  Directional Bezier basis functions B at s and t:\n"
"    float Bs[4], Bds[4], Bdss[4];\n"
"    float Bt[4], Bdt[4], Bdtt[4];\n"
"\n"
"    OsdGetBezierWeights(s, Bs, OSD_OPTIONAL_INIT(wDs, Bds), OSD_OPTIONAL_INIT(wDss, Bdss));\n"
"    OsdGetBezierWeights(t, Bt, OSD_OPTIONAL_INIT(wDt, Bdt), OSD_OPTIONAL_INIT(wDtt, Bdtt));\n"
"\n"
"    //  Rational multipliers G at s and t:\n"
"    float sC = 1.0f - s;\n"
"    float tC = 1.0f - t;\n"
"\n"
"    //  Use <= here to avoid compiler warnings -- the sums should always be non-negative:\n"
"    float df0 = s  + t;   df0 = (df0 <= 0.0f) ? 1.0f : (1.0f / df0);\n"
"    float df1 = sC + t;   df1 = (df1 <= 0.0f) ? 1.0f : (1.0f / df1);\n"
"    float df2 = sC + tC;  df2 = (df2 <= 0.0f) ? 1.0f : (1.0f / df2);\n"
"    float df3 = s  + tC;  df3 = (df3 <= 0.0f) ? 1.0f : (1.0f / df3);\n"
"\n"
"    float G[8] = OSD_ARRAY_8(float, s*df0, t*df0,  t*df1, sC*df1,  sC*df2, tC*df2,  tC*df3, s*df3 );\n"
"\n"
"    //  Combined weights for boundary and interior points:\n"
"    for (int i = 0; i < 12; ++i) {\n"
"        wP[boundaryGregory[i]] = Bs[boundaryBezSCol[i]] * Bt[boundaryBezTRow[i]];\n"
"    }\n"
"    for (int i = 0; i < 8; ++i) {\n"
"        wP[interiorGregory[i]] = Bs[interiorBezSCol[i]] * Bt[interiorBezTRow[i]] * G[i];\n"
"    }\n"
"\n"
"    //\n"
"    //  For derivatives, the basis functions for the interior points are rational and ideally\n"
"    //  require appropriate differentiation, i.e. product rule for the combination of B and G\n"
"    //  and the quotient rule for the rational G itself.  As initially proposed by Loop et al\n"
"    //  though, the approximation using the 16 Bezier points arising from the G(s,t) has\n"
"    //  proved adequate (and is what the GPU shaders use) so we continue to use that here.\n"
"    //\n"
"    //  An implementation of the true derivatives is provided for future reference -- it is\n"
"    //  unclear if the approximations will hold up under surface analysis involving higher\n"
"    //  order differentiation.\n"
"    //\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        bool find_second_partials = OSD_OPTIONAL(wDs && wDst && wDtt);\n"
"        //  Remember to include derivative scaling in all assignments below:\n"
"        float d2Scale = dScale * dScale;\n"
"\n"
"        //  Combined weights for boundary points -- simple (scaled) tensor products:\n"
"        for (int i = 0; i < 12; ++i) {\n"
"            int iDst = boundaryGregory[i];\n"
"            int tRow = boundaryBezTRow[i];\n"
"            int sCol = boundaryBezSCol[i];\n"
"\n"
"            wDs[iDst] = Bds[sCol] * Bt[tRow] * dScale;\n"
"            wDt[iDst] = Bdt[tRow] * Bs[sCol] * dScale;\n"
"\n"
"            if (find_second_partials) {\n"
"                wDss[iDst] = Bdss[sCol] * Bt[tRow] * d2Scale;\n"
"                wDst[iDst] = Bds[sCol] * Bdt[tRow] * d2Scale;\n"
"                wDtt[iDst] = Bs[sCol] * Bdtt[tRow] * d2Scale;\n"
"            }\n"
"        }\n"
"\n"
"        // dclyde's note: skipping half of the product rule like this does seem to change the result a lot in my tests.\n"
"        // This is not a runtime bottleneck for cloth sims anyway so I'm just using the accurate version.\n"
"#ifndef OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES\n"
"        //  Approximation to the true Gregory derivatives by differentiating the Bezier patch\n"
"        //  unique to the given (s,t), i.e. having F = (g^+ * f^+) + (g^- * f^-) as its four\n"
"        //  interior points:\n"
"        //\n"
"        //  Combined weights for interior points -- (scaled) tensor products with G+ or G-:\n"
"        for (int i = 0; i < 8; ++i) {\n"
"            int iDst = interiorGregory[i];\n"
"            int tRow = interiorBezTRow[i];\n"
"            int sCol = interiorBezSCol[i];\n"
"\n"
"            wDs[iDst] = Bds[sCol] * Bt[tRow] * G[i] * dScale;\n"
"            wDt[iDst] = Bdt[tRow] * Bs[sCol] * G[i] * dScale;\n"
"\n"
"            if (find_second_partials) {\n"
"                wDss[iDst] = Bdss[sCol] * Bt[tRow] * G[i] * d2Scale;\n"
"                wDst[iDst] = Bds[sCol] * Bdt[tRow] * G[i] * d2Scale;\n"
"                wDtt[iDst] = Bs[sCol] * Bdtt[tRow] * G[i] * d2Scale;\n"
"            }\n"
"        }\n"
"#else\n"
"        //  True Gregory derivatives using appropriate differentiation of composite functions:\n"
"        //\n"
"        //  Note that for G(s,t) = N(s,t) / D(s,t), all N' and D' are trivial constants (which\n"
"        //  simplifies things for higher order derivatives).  And while each pair of functions\n"
"        //  G (i.e. the G+ and G- corresponding to points f+ and f-) must sum to 1 to ensure\n"
"        //  Bezier equivalence (when f+ = f-), the pairs of G' must similarly sum to 0.  So we\n"
"        //  can potentially compute only one of the pair and negate the result for the other\n"
"        //  (and with 4 or 8 computations involving these constants, this is all very SIMD\n"
"        //  friendly...) but for now we treat all 8 independently for simplicity.\n"
"        //\n"
"        //float N[8] = OSD_ARRAY_8(float,    s,     t,      t,     sC,      sC,     tC,      tC,     s );\n"
"        float D[8] = OSD_ARRAY_8(float,  df0,   df0,    df1,    df1,     df2,    df2,     df3,   df3 );\n"
"\n"
"        OSD_DATA_STORAGE_CLASS const float Nds[8] = OSD_ARRAY_8(float, 1.0f, 0.0f,  0.0f, -1.0f, -1.0f,  0.0f,  0.0f,  1.0f );\n"
"        OSD_DATA_STORAGE_CLASS const float Ndt[8] = OSD_ARRAY_8(float, 0.0f, 1.0f,  1.0f,  0.0f,  0.0f, -1.0f, -1.0f,  0.0f );\n"
"\n"
"        OSD_DATA_STORAGE_CLASS const float Dds[8] = OSD_ARRAY_8(float, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f );\n"
"        OSD_DATA_STORAGE_CLASS const float Ddt[8] = OSD_ARRAY_8(float, 1.0f, 1.0f,  1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f );\n"
"\n"
"        //  Combined weights for interior points -- (scaled) combinations of B, B', G and G':\n"
"        for (int i = 0; i < 8; ++i) {\n"
"            int iDst = interiorGregory[i];\n"
"            int tRow = interiorBezTRow[i];\n"
"            int sCol = interiorBezSCol[i];\n"
"\n"
"            //  Quotient rule for G' (re-expressed in terms of G to simplify (and D = 1/D)):\n"
"            float Gds = (Nds[i] - Dds[i] * G[i]) * D[i];\n"
"            float Gdt = (Ndt[i] - Ddt[i] * G[i]) * D[i];\n"
"\n"
"            //  Product rule combining B and B' with G and G' (and scaled):\n"
"            wDs[iDst] = (Bds[sCol] * G[i] + Bs[sCol] * Gds) * Bt[tRow] * dScale;\n"
"            wDt[iDst] = (Bdt[tRow] * G[i] + Bt[tRow] * Gdt) * Bs[sCol] * dScale;\n"
"\n"
"            if (find_second_partials) {\n"
"                float Dsqr_inv = D[i]*D[i];\n"
"\n"
"                float Gdss = 2.0f * Dds[i] * Dsqr_inv * (G[i] * Dds[i] - Nds[i]);\n"
"                float Gdst = Dsqr_inv * (2.0f * G[i] * Dds[i] * Ddt[i] - Nds[i] * Ddt[i] - Ndt[i] * Dds[i]);\n"
"                float Gdtt = 2.0f * Ddt[i] * Dsqr_inv * (G[i] * Ddt[i] - Ndt[i]);\n"
"\n"
"                wDss[iDst] = (Bdss[sCol] * G[i] + 2.0f * Bds[sCol] * Gds + Bs[sCol] * Gdss) * Bt[tRow] * d2Scale;\n"
"                wDst[iDst] = (Bt[tRow] * (Bs[sCol] * Gdst + Bds[sCol] * Gdt) + Bdt[tRow] * (Bds[sCol] * G[i] + Bs[sCol] * Gds)) * d2Scale;\n"
"                wDtt[iDst] = (Bdtt[tRow] * G[i] + 2.0f * Bdt[tRow] * Gdt + Bt[tRow] * Gdtt) * Bs[sCol] * d2Scale;\n"
"            }\n"
"        }\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"#endif /* OPENSUBDIV3_OSD_PATCH_BASIS_COMMON_H */\n"
"\n"
